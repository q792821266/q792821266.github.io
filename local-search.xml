<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>值传递</title>
    <link href="/2025/09/02/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <url>/2025/09/02/%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><blockquote><p><a href="https://segmentfault.com/a/1190000045243970">https://segmentfault.com/a/1190000045243970</a></p><p>metaso.cn</p></blockquote><p>先说结论：Java中只有<strong>值传递</strong>。即使是引用类型变量传递时也是传递引用的副本，当你修改了副本所指是不会影响原对象的，始终保持了对值的修改不会影响对象本身，效果等同于值传递。</p><p><font style="color:rgb(36, 41, 47);">Java中变量只是对象的引用。实际的对象，即实例，在堆内存中。</font></p><h2 id="“引用”-vs-“实例”的区别"><a href="#“引用”-vs-“实例”的区别" class="headerlink" title="“引用” vs “实例”的区别"></a><strong><font style="color:rgb(36, 41, 47);">“引用” vs “实例”的区别</font></strong></h2><table><thead><tr><th></th><th><strong><font style="color:rgb(36, 41, 47);">引用 (Reference)</font></strong></th><th><strong><font style="color:rgb(36, 41, 47);">实例 (Instance&#x2F;Object)</font></strong></th></tr></thead><tbody><tr><td><strong><font style="color:rgb(36, 41, 47);">存储位置</font></strong></td><td><font style="color:rgb(36, 41, 47);">Java栈内存 (Stack)</font></td><td><font style="color:rgb(36, 41, 47);">Java堆内存 (Heap)</font></td></tr><tr><td><strong><font style="color:rgb(36, 41, 47);">本质</font></strong></td><td><em>指针</em><font style="color:rgb(36, 41, 47);">（指向对象的地址）</font></td><td><em>真实的数据</em></td></tr><tr><td><strong><font style="color:rgb(36, 41, 47);">示例</font></strong></td><td><code>&lt;font style=&quot;color:rgb(36, 41, 47);&quot;&gt;Person p;&lt;/font&gt;</code></td><td><code>&lt;font style=&quot;color:rgb(36, 41, 47);&quot;&gt;new Person();&lt;/font&gt;</code></td></tr><tr><td><strong><font style="color:rgb(36, 41, 47);">生命周期</font></strong></td><td><em>方法执行期间</em></td><td><em>直到被垃圾回收</em></td></tr></tbody></table><h2 id="💥易错场景解析"><a href="#💥易错场景解析" class="headerlink" title="💥易错场景解析"></a><font style="color:rgb(36, 41, 47);">💥</font><font style="color:rgb(36, 41, 47);">易错场景解析</font></h2><h3 id="❌误区1：「-」⽐较的是引⽤⽽⾮内容"><a href="#❌误区1：「-」⽐较的是引⽤⽽⾮内容" class="headerlink" title="❌误区1：「&#x3D;&#x3D;」⽐较的是引⽤⽽⾮内容"></a><font style="color:rgb(36, 41, 47);">❌</font><font style="color:rgb(36, 41, 47);">误区1：「&#x3D;&#x3D;」⽐较的是引⽤⽽⾮内容</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.println(s1 == s2); <span class="hljs-comment">// false (⽐较的是地址)</span><br>System.out.println(s1.equals(s2)); <span class="hljs-comment">// true (⽐较的是内容)</span><br><br></code></pre></td></tr></table></figure><h3 id="❌误区2：「传参」本质是「传引⽤副本」"><a href="#❌误区2：「传参」本质是「传引⽤副本」" class="headerlink" title="❌误区2：「传参」本质是「传引⽤副本」"></a><font style="color:rgb(36, 41, 47);">❌</font><font style="color:rgb(36, 41, 47);">误区2：「传参」本质是「传引⽤副本」</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(List list)</span> &#123;<br>    list.add(<span class="hljs-number">100</span>); <span class="hljs-comment">// ✅会影响原始list(同⼀个引⽤)</span><br>    list = <span class="hljs-literal">null</span>;   <span class="hljs-comment">// ❌不会影响外部list(只是副本置空)</span><br>&#125;<br><br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>modify(myList);<br>System.out.println(myList.size()); <span class="hljs-comment">//输出1(证明修改有效)</span><br><br></code></pre></td></tr></table></figure><p>这里方法传参的list是副本，当第三行代码执行的时候list 指向了null ， 外面的myList 依然指向的是new ArrayList()这个实例。 </p><h3 id="❌误区3：「多引⽤共享」导致意外修改"><a href="#❌误区3：「多引⽤共享」导致意外修改" class="headerlink" title="❌误区3：「多引⽤共享」导致意外修改"></a><font style="color:rgb(36, 41, 47);">❌</font><font style="color:rgb(36, 41, 47);">误区3：「多引⽤共享」导致意外修改</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, List&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">List</span> <span class="hljs-variable">sharedList</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>map.put(<span class="hljs-string">&quot;key&quot;</span>, sharedList);<br>sharedList.add(<span class="hljs-number">100</span>); <span class="hljs-comment">// map中的List也被修改!</span><br><br><br>List&lt;String&gt; original = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>List&lt;String&gt; copyRef = original; <br><br>copyRef.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;X&quot;</span>); <br>System.out.println(original.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">//输出X  </span><br></code></pre></td></tr></table></figure><p>这里因为指向的是同一个对象，所以调用方法会直接修改到对象本身的。</p><h3 id="❌误区4：「未初始化」引发NPE"><a href="#❌误区4：「未初始化」引发NPE" class="headerlink" title="❌误区4：「未初始化」引发NPE"></a><font style="color:rgb(36, 41, 47);">❌</font><font style="color:rgb(36, 41, 47);">误区4：「未初始化」引发NPE</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person p;<br>p.getName(); <span class="hljs-comment">// NullPointerException!</span><br></code></pre></td></tr></table></figure><h3 id="❌误区5：「Final」可修改"><a href="#❌误区5：「Final」可修改" class="headerlink" title="❌误区5：「Final」可修改"></a><font style="color:rgb(36, 41, 47);">❌</font><font style="color:rgb(36, 41, 47);">误区5：「Final」可修改</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.setName(<span class="hljs-string">&quot;Tom&quot;</span>); <span class="hljs-comment">// ✔可以修改实例的属性</span><br>p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// ❌不能重新赋值！</span><br></code></pre></td></tr></table></figure><p>被final修饰的引用对象本身不可以修改，但是你可以调用它的方法做到修改属性。这样是符合不可修改引用本身。</p><h2 id="🛠最佳实践"><a href="#🛠最佳实践" class="headerlink" title="🛠最佳实践"></a><font style="color:rgb(36, 41, 47);">🛠</font><font style="color:rgb(36, 41, 47);">最佳实践</font></h2><h3 id="✅防御性编程技巧"><a href="#✅防御性编程技巧" class="headerlink" title="✅防御性编程技巧"></a><font style="color:rgb(36, 41, 47);">✅</font><font style="color:rgb(36, 41, 47);">防御性编程技巧</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ⽅法参数校验(防NPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(List data)</span> &#123;<br>    Objects.requireNonNull(data);<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Collections.unmodifiableList防篡改</span><br><span class="hljs-type">List</span> <span class="hljs-variable">safeList</span> <span class="hljs-operator">=</span> Collections.unmodifiableList(originalList);<br><br></code></pre></td></tr></table></figure><h3 id="✅「深拷贝」隔离修改"><a href="#✅「深拷贝」隔离修改" class="headerlink" title="✅「深拷贝」隔离修改"></a><font style="color:rgb(36, 41, 47);">✅</font><font style="color:rgb(36, 41, 47);">「深拷贝」隔离修改</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; realCopy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(original);<br>realCopy.set(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;X&quot;</span>); <br>System.out.println(original.get(<span class="hljs-number">0</span>)); <span class="hljs-comment">//仍输出A </span><br></code></pre></td></tr></table></figure><h3 id="✅合理使⽤「四种引⽤」"><a href="#✅合理使⽤「四种引⽤」" class="headerlink" title="✅合理使⽤「四种引⽤」"></a><font style="color:rgb(36, 41, 47);">✅</font><font style="color:rgb(36, 41, 47);">合理使⽤「四种引⽤」</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 「软引⽤」适合缓存(内存不⾜时GC)</span><br>SoftReference&lt;<span class="hljs-type">byte</span>[]&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(bigData);<br><br><span class="hljs-comment">// 「弱引⽤」适合监听器(不影响GC)</span><br>WeakReference&lt;Listener&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(listener);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java 基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ入门</title>
    <link href="/2024/09/08/RocketMQ/"/>
    <url>/2024/09/08/RocketMQ/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RocketMQ是由阿里捐赠给Apache的一款分布式、队列模型的开源消息中间件，经历了淘宝双十一的洗礼。</p><h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647850850657-8219ad44-c38a-4772-a6be-997459f8cc6b.png"></p><p>2017年孵化了4.0版本</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647850898154-88fa74dd-f26c-409a-a0f1-54ef09efdab7.png"></p><p>原生的分布式，在设置RocketMQ的时候就是考虑到分布式的场景。消息顺序可以自己制定。RocketMQ有自己的NameServer，自己去实现了集群间信息的同步。以及的消息堆积下性能也很好。类似kafka组的概念，能更好的将消息负载到不同的机器上，均衡压力。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>producer ：消息生产者，负责产生消息，一般由业务系统负责产生消息</li><li>consumer ：消息消费者，负责消费消息，一般是后台系统负责异步消息</li><li>push consumer ： 封装消息拉取，消费进度和内部</li><li>pull consumer ： 主动拉取消息，一旦拉取到消息，应用的消费进程就会进行初始化</li><li>Producer Group ：一类Producer的集合名称，这类Producer通常发送一类消息，且发送逻辑一致</li><li>Consumer Group：一类Consumer的集合名臣，这些Consumer通常消费一类消息，且消费逻辑一致</li><li>Broker：消息中转角色，负责存储消息，转发消息，这里就是RocketMQ Server</li><li>Topic：消息的主题，用于定义并在服务端配置，消费者可以按照主题进行订阅，也就是消息分类，通常一个系统一个topic。</li><li>Message：在生产者、消费者、服务器之间传递，一个message必须属于一个topic</li><li>Namesrv：一个无状态的名称服务，可以集群部署，每一个broker启动的时候都会向名称服务器注册，主要是接收broker的注册，接收客户端的路由请求并返回路由信息</li><li>Offset：偏移量，消费者拉取消息时需要知道上一次消费到了什么位置，这一次从哪里开始</li><li>Partition：分区，Topic物理上的分组，一个Topic可以分为多个分区，每个分区都是一个有序的队列。分区的每条消息都会分配一个有序的ID，也就是偏移量</li><li>Tag：用于对消息进行过滤，可以理解为message的标记，同一个业务不同目的的message可以用相同的topic但是可以用不同的tag来区分。这也是为什么RocketMQ只用一个topic的原因。</li><li>key：消费的key字段是为了唯一标识消息，方便查问题，不是说必须设置，但是设置之后会方便开发和运维的定位工作，这个key可以是订单ID等。</li></ul><p>安装运行，可以参考文档。</p><p>运行环境为Centos7，JDK1.8</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912183178-f19648b5-fff9-44ca-b93b-b3bdd573d425.png"></p><p>下载完成后</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912165861-9a18909f-fc35-4b90-b029-c855a0a629a3.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912202268-f592c4f9-022b-44b2-af90-dbffdc2bc6ac.png"></p><p>namesev 启动默认会吃掉4G的内存，而broker默认用掉8G，如果测试服务器没有那么高的内存，启动可能报告错误，需要修改配置文件。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912305419-f43f7166-5f5a-43b7-aa23-eef803f8eb7f.png"></p><p>RocketMQ提供了quickstart，可以快速实现消息的接收与发送。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912321035-49781e39-1b7b-418a-b1ae-323b1ba47b8c.png"></p><h1 id="架构方案及角色详解"><a href="#架构方案及角色详解" class="headerlink" title="架构方案及角色详解"></a>架构方案及角色详解</h1><h2 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h2><p>RocketMQ由四个角色组成</p><ul><li>Producer：消费生产者</li><li>Consumer：消费者</li><li>Broker：MQ服务、负责接收、分发消息</li><li>NameServer：负责MQ服务之间的协调</li></ul><h2 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a>架构方案</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647913861700-390a09ae-ffa4-4574-9ac2-ad4c91ce4022.png">NameServer负责服务发现，每一个MQ服务启动之后会将自己的服务信息组测到NameServer上面，生产者和消费者通过与NameServer建立连接，来知道当前有哪些MQ可以连接。这个过程就是服务发现。</p><p>NameServer提供服务注册与发现，还提供路由管理的功能。</p><p>当消费者或者生产者选择了一个MQ服务来进行连接，那么连接信息，比如当前生产者连接哪个broker，传输什么消息，处理的是哪个topic，这些都是保存在NameServer。Broker负责的是数据的真实存储和消息的接收与分发。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647914241395-d14bc83a-9b8e-42b3-b9b0-2eebfc43e170.png"></p><p>继续来详细介绍一下，nameServer 存放mq的服务信息、路由关系、topic、消费者、生产者，而Broker就是实际提供服务的节点。不管是消息发送还是接收，消息都需要有个topic，这个topic数据存放在什么地方，这就涉及到topic的分区。因为是分布式的，所以topic会被分到多个服务器存储。如果是启动了两个broker，这两个broker都是要向nameserver去注册自己的服务信息的。topic就会被分为两个分区去存储，分多少个分区nameserver是会知道的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647930922932-d19dc00b-c09c-4615-862e-fdfbc731d752.png"></p><p>broker在实际存储的时候，由于topic partition里面还有queue的概念，这个queue个数也是可以配置的（默认4个）。实际上存储到对应的queue里面。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647931052464-17c495ba-2064-464b-8ecf-88262ccf5d19.png"></p><p>由于里面可能有很多个queue，那么消费者要怎么样才能消费到呢？这是一个消费分发的问题。</p><p>consumer负责和其中一台broker建立连接，所以consumer也是要有多个实例的。</p><p>考虑启动consumer的情况去消费topic-test，当消费者和namesvr建立连接之后，namesvr会分配一个broker给消费者，broker就会和消费者建立长连接，消费方式只有pull，就算是push模式也是建立在pull上。当第二个消费者再过来连接nameserver的时候，因为nameserver是知道集群中topic，消费者和生产者的关系的，所以nameserver知道partition1是有消费者在消费的，所以会分配partition2给后来的消费者。如果partition中有多个queue，那么消费者会把多个queue都订阅下来消费。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647931450148-5101eb5f-41be-4cae-9674-b68aaa04b6fc.png"></p><p>上面就是底层实现的一些白话。</p><p>消费者与partition尽量保持一样的数量，也可以多部署一些消费者，但是如果数量比queue还多，那么其实消费能力是没有提升的。</p><p><strong>一个queue只能有一个消费者去消费，一个消费者可以消费多个queue。</strong>RocketMQ默认一个topic创建4个Queue</p><p>通过web管理控制台可以监控查看rocketMQ。</p><p>Producer 、 Consumer 、Broker三者的关系是比较简单的。复杂点在于broker除了简单使用外，还有broker的高可用，消息发送到broker，出现异常情况怎么保证消息不丢失。消息数据存储到磁盘，有两种方式，同步或异步。</p><ul><li>异步：数据会现在内存中存下来，隔一段时间才刷入磁盘，并且不管是否刷入磁盘会立刻返回给客户端。</li><li>同步：数据写入磁盘后，才会给客户端响应消息成功送达。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647932318487-494f17a0-3680-4c3e-9218-f8225dc8ad2f.png"></p><p>响应写入磁盘成功后，如果机器宕机还是会导致数据丢失，于是可以给broker做主从集群。当数据过来写入，到达主服务器写入磁盘之后，主从之间会把消息同步到从服务器。主从同步也是存在同步还是异步的方式，如果是异步，也会出现同步数据丢失的情况。如果设置的是同步的方式，那么消息必须写入从服务器磁盘才会响应客户端，实现高可用。从服务器可以配置多台。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647932564276-37b23494-936b-442b-9777-3043a8f597aa.png"></p><h1 id="搭建与运行RocketMQ"><a href="#搭建与运行RocketMQ" class="headerlink" title="搭建与运行RocketMQ"></a>搭建与运行RocketMQ</h1><p>RocketMQ默认启动就要吃掉8G的内存，我们学习不需要这么高的占用，那就去修改一下配置。</p><p>在启动命令里面修改<code>runserver.sh</code>，命名服务器的配置修改</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647914997560-e9ecc17c-9765-4efc-80e2-4e855de07cf8.png"></p><p>将内存使用大小改为2G，减少资源占用</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647915038376-6d51602b-954f-4e9c-83c3-a60c366a578a.png"></p><p>同理broker部分也需要修改</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647915098008-3aac0c0b-e1c5-4565-88b8-fd8567f2977c.png"></p><p>修改完成后进行后台启动<code>nohup sh bin/mqnamesrv &gt; logs/namesrv.log 2&gt;&amp;1 &amp; </code></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647920928701-92c1ace1-6199-4f00-932b-941f3df15175.png"></p><p>接下来要启动broker，broker加载的配置在conf目录下的<code>broker.conf</code>。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921035070-d219f392-f31f-4649-a986-1fbaf7321f21.png"></p><p>比如设置了双网卡，让外网也能访问到MQ，那么就在这里面指定IP，这样IP会被发布到nameserver注册。这样就可以让外部服务进行使用。这样外部就能通过设置的IP进行访问。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921296201-e475e701-18f5-455a-b8fe-fd569991e30b.png"></p><p>这个配置文件还可以配置nameserver的目的地。用于告诉broker nameserver的地址，这样才能注册信息上去。但是我们演示的时候用命令行的方式去指定。 <code>nohup sh bin/mqbroker -c conf/broker.conf -n localhost:9876 &gt; logs/broker.log 2&gt;&amp;1 &amp;</code></p><p>-c 制定了配置文件，-n 指定了nameserver地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921690824-806730bc-6f6e-4f24-ab26-43990fd8c4c2.png"></p><p>这样就完成了RocketMQ的启动了。</p><p>bin目录下有mqadmin，可以查询与控制集群。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921819236-9a3489ac-19e5-4435-865d-618ea1866745.png"></p><p>如果没有把nameserver配置为环境变量，那么就需要指定一下nameserver的地址才能调用clusterList</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647924616070-251c977e-fe41-4fed-8722-31bbb23732ac.png"></p><p>代码示例在rocketMQ-demo。运行代码的过程中可能报告错误</p><p>生产者启动后，发送消息时会报以下错：</p><p><code>Exception in thread &quot;main&quot; org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, TopicTest</code></p><p>原因：</p><p>使用RocketMQ进行发消息时，必须要指定topic，对于topic的设置有一个开关autoCreateTopicEnable，一般在开发测试环境中会使用默认设置autoCreateTopicEnable &#x3D; true，但是这样就会导致topic的设置不容易规范管理，没有统一的审核等等，所以在正式环境中会在Broker启动时设置参数autoCreateTopicEnable &#x3D; false。<em>然而，目前的版本中，autoCreateTopicEnable设置为true也不会生效</em></p><p>解决方法：</p><p>手动通过命令或管理界面创建主题</p><p><code>/usr/rocketmq/bin/mqadmin updateTopic -n &#39;192.168.100.242:9876&#39; -c DefaultCluster -t TopicTest</code></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647943844317-d2f6cdda-bb26-4d95-b165-62690d387d32.png"></p><h1 id="集群配置与搭建"><a href="#集群配置与搭建" class="headerlink" title="集群配置与搭建"></a>集群配置与搭建</h1><p>在rocketMQ里面提供了主从集群的配置。<img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647932830661-534997d8-5247-4d8d-ad94-41c574e1b266.png"><br>2master-2slave-asyns，就是双主双从异步同步。</p><p>要注意master之间是不会做数据交互的，数据调度全靠nameServer。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647933025589-39a8423a-9ddc-421f-9c4d-cea6a2f05070.png"></p><p>文件夹下面是四份配置文件，配置文件的配置项可以去官方看看文档，下图上也有部分配置的简单介绍。</p><p>双主双从的话 我们需要六台服务器，nameserver 2台，master 2台，replic 2台。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647933221405-f8704629-ffb4-4ac8-bed5-2c7383d953f3.png"></p><p>namaserver之间也不存在数据同步，所以有多少个nameserver，broker启动的时候就要在都要注册上去。</p><p>对应broker的配置：</p><ul><li>通过brokerClusterName来标识集群，同名就是同一个集群。</li><li>同一个broker主从集群的brokerName是一致的。</li><li>通过brokerId 来分辨master与replic ,0代表master 非0代表slave</li><li>brokeRole代表主从复制方式，同步或异步</li><li>flushDiskType代表内存数据写入磁盘的方式，同步或异步。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938251268-dfbadee4-fbe7-4552-b717-f42026c640da.png"></p><p>还是要注意一个队列只能有一个消费者去消费，一个消费者可以消费多个队列。只有一个queue搞再多的consumer都没啥用。   </p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938395212-d3d3e3dd-3bee-4e80-9f3f-fe092fce0152.png"></p><p>数据堆积的大小，清理数据的规则都可以通过配置来完成。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938482384-3aeb2f12-125e-4da0-a02c-c0c834296f1a.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938554390-f7af7e4b-ea5f-4353-8e66-13078fa24ddf.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938565992-8f785fb7-921d-4070-9a06-7fb23b84f1ef.png"></p><p>看一眼混个眼熟，知道有这么个东西就好。</p><h1 id="有序消息"><a href="#有序消息" class="headerlink" title="有序消息"></a>有序消息</h1><h2 id="有序消息的基本概念"><a href="#有序消息的基本概念" class="headerlink" title="有序消息的基本概念"></a>有序消息的基本概念</h2><p>为什么我们需要有序消息。举个例子，我们去银行存钱和取钱，收到用户的请求之后，会发送短信给客户，存钱和取钱的短信通知，可能是同一个sms-topic在物理上分成多个partition。在逻辑上存储在queue，这两个通知会发送到不同的队列中，如果你突然收到一条取钱的短信，估计会被吓一跳。这时候保证消息的顺序是能提高用户的体验的。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938826434-57c1ce8e-6a36-4b00-b762-633592ad8588.png"></p><p>那么为了保证消息的顺序，就需要把消息发送到同一个queue中，保证只有一个消费者消费，queue本身就是FIFO的保证。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647939164090-b1749752-62b2-4fd7-a747-8ed8ebdfcb13.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647939237781-b417eed3-a5d4-46ab-adb2-b0a30d2e1d65.png"></p><h3 id="全局顺序"><a href="#全局顺序" class="headerlink" title="全局顺序"></a>全局顺序</h3><p>一个Topic内所有消息都发布到同一个queue，按照先进先出的顺序进行发布和消费。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647940074265-54326dd2-e0ac-42c9-8624-cce29e175944.png"></p><p>适用场景：性能要求不高，所有的消息严格按照FIFO原则进行消息发布和消费的场景。</p><p>建议的是一个系统一个topic，所以如果再限制一个queue那效率其实就不高了。</p><h3 id="分区顺序"><a href="#分区顺序" class="headerlink" title="分区顺序"></a>分区顺序</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647940631324-70e2684a-5ba0-4549-8796-d9b2a9390276.png"></p><p>根据消息中的sharding key来进行分区，比如让某种类型统一发送到一个queue中。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647940820102-56e6fd0d-3a14-40da-bad5-d1d75ef11fd3.png"></p><p>根据sharding key来分配。</p><p>适用场景：性能要求高，可根据消息中的sharding key去决定消息发送到哪一个queue。</p><p>代码示例OrderedProducer.java</p><h3 id="全局消息与分区消息对比"><a href="#全局消息与分区消息对比" class="headerlink" title="全局消息与分区消息对比"></a>全局消息与分区消息对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648000569541-e277b67f-3cc3-4136-a5c8-8393f751d0ad.png"></p><p>发送方式对比</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648000737617-c24fcec0-f2d4-4f01-aa8e-7bf961144522.png"></p><p>oneway就是单向发送，比如发送日志消息，不返回任何值，调用者也不关心成功或者失败</p><h2 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648000909174-9e45d54d-80c3-4f80-995e-edd1072da61c.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648001017624-9b8f7603-8d20-43b6-ae99-36974127475a.png"></p><p>全局消息只能通过一个消费者来消费，所以性能不高</p><p>首先需要顺序的消息必须存储到同一个queue中，这个由producer端实现<code>_&lt;font style=&quot;color:#6c71c4;&quot;&gt;MessageQueueSelector&lt;/font&gt;_</code>  来完成保证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageQueueSelector</span> <span class="hljs-variable">messageQueueSelector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br>    <span class="hljs-comment">// 最后一个参数Object o就是上面讲的sharding key</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; mqs, Message msg, Object o)</span> &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Integer) o;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> id % mqs.size();<br>                <span class="hljs-comment">//分区顺序，同一个模值的消息发送到同一个队列中</span><br>                <span class="hljs-keyword">return</span> mqs.get(index);<br><br>                <span class="hljs-comment">//全局顺序，所有消息发送到一个队列</span><br>                <span class="hljs-comment">//return mqs.get(mqs.size() - 1);</span><br>            &#125;<br>        &#125;;<br><br><span class="hljs-comment">//发送的时候要指定selector 和 sharding key</span><br>SendResult sendResult= producer.send(msg,messageQueueSelector,bizData.get(<span class="hljs-string">&quot;msgType&quot;</span>));<br></code></pre></td></tr></table></figure><p>consumer端接收到顺序消费的时候也需要保证消息处理的顺序 ，consumer的关键点在于MessageListenerConcurrently 与  MessageListenerOrderly的注册上。如果是concurrently的话意味并发处理，可能前一条消息没有处理完成，下一条消息就被处理完了，这样是没法保证有序性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注1：普通消息消费</span><br>        <span class="hljs-comment">/*consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="hljs-comment">            AtomicInteger count = new AtomicInteger(0);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123;</span><br><span class="hljs-comment">                doBiz(list.get(0));</span><br><span class="hljs-comment">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;);*/</span><br><br>        pushConsumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerOrderly</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeOrderlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;<br>                context.setAutoCommit(<span class="hljs-literal">true</span>);<br>                doBiz(msgs.get(<span class="hljs-number">0</span>));<br>                <span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUCCESS;<br>                        <br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>这样才能保证整个消息声明周期的有序。</p><h2 id="有序消息的原理"><a href="#有序消息的原理" class="headerlink" title="有序消息的原理"></a>有序消息的原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648004637408-1942b439-6885-43ae-b71e-a5949da41819.png"></p><p>消息发送的时候，存储在queue可以保证有序性，消费读取消息的时候也能够保证有序。但是有一个点，客户端代码如果没有写好的话是可以造成顺序不一致的。情况不是发生在取数据的过程，而是消费过程处理速率不一致导致的。</p><p>RocketMQ消费端有两种类型：MQPullConsumer和MQPushConsumer。本质上底层都是通过pull机制去实现，长轮询（long pull）没有数据会等待而不会断开。pushConsumer是一种API封装。</p><h3 id="MQPullConsumer"><a href="#MQPullConsumer" class="headerlink" title="MQPullConsumer"></a>MQPullConsumer</h3><p>MQPullConsumer由用户控制线程，客户端自己通过代码去broker循环拿数据，主动从服务器获取消息，每次获取到的是一个MessageQueue中的消息。PullResult中的<code>List&lt;MessageExt&gt; msgFoundList</code> 自然和存储顺序一致，用户需要在拿到这批消息之后需要自己保证消费的顺序。意味着你可以拿到1 、2、3这样次序的数据，但是先处理2、3，再处理1，处理的逻辑由自己实现。</p><h3 id="MQPushConsumer"><a href="#MQPushConsumer" class="headerlink" title="MQPushConsumer"></a>MQPushConsumer</h3><p>MQPushConsumer，通过封装的pull实现。用户通过注册MessageListener来消费消息，在客户端中需要保证调用MessageListener时消息的顺序性。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005304416-cd8343c7-07a9-4b66-bc5a-da5a5321065b.png"></p><p>在RocketMQ中，实现顺序消息有两个核心类：</p><ol><li>PullMessageService，目的是去Broker拉取消息，并将消息放在本地的ProcessQueue中</li><li>ProcessQueue，我们业务代码处理的数据源头就是这个ProcessQueue</li></ol><p>不管是pull还是push都是按照上图这种流程。顺序的保证在ProcessQueue中实现。</p><p>示例代码中使用到的OrderlyService，核心思路是当多个线程处理同一个processQueue（此时数据其实已经被拉到本地了），会锁住processQueue，不同的queue会有不同线程加锁处理。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005373957-43242cf8-bab2-435f-8cdf-25ad39df25ad.png"></p><p>结合源码看看：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005721096-51bae813-a0c4-4270-96c1-fd34a1c4c9db.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005734246-492ca577-8849-428d-aa2c-6c8ff569c558.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005747532-210ccf2d-7b05-469b-a828-47d6bc7bc87c.png"></p><p>在这个start漆面启动了很多的东西，我们关注</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005782651-fa715e5d-da3d-49fa-a811-fc51e913e5d3.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005820648-eda9eea4-1377-4b59-a301-369d9d600406.png"></p><p>这就是去broker拉取消息。</p><p>将messageListener注册上去之后会进行判断：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648006390048-4d37efc4-3ae4-4e68-8dec-19e0c89dc47a.png"></p><p>如果是顺序的，那么就可以看到<code>start()</code> 里面存在锁的机制使用。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648006456603-c3974651-7d3d-4cd6-bb25-1cbca64789fe.png"></p><h2 id="有序消息的缺陷"><a href="#有序消息的缺陷" class="headerlink" title="有序消息的缺陷"></a>有序消息的缺陷</h2><p>有序消息使用场景其实并不是很多。有序消息没法利用到集群的故障转移功能，毕竟只有一个queue，没法重试。也可能因为数据热点问题导致一些queue数据量特别大，然后consumer的处理能力却无法提升的尴尬场景。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648006542933-88040553-2549-47d5-a6e9-51c7705b97c4.png"></p><ul><li>消费的并行读依赖于queue数量</li><li>消费失败时无法跳过（可能可以消费者端自己做处理）</li></ul><h2 id="有序消息的使用"><a href="#有序消息的使用" class="headerlink" title="有序消息的使用"></a>有序消息的使用</h2><p>参考官网教程： <a href="https://rocketmq.apache.org/docs/4.x/producer/03message2/">https://rocketmq.apache.org/docs/4.x/producer/03message2/</a></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648007130799-b40fa572-7975-4400-a7db-799fe02cad0b.png"></p><p>是不是有点无语，我当时也是这么无语。当然，学会看官方文档是学习新技术很重要的手段。</p><hr><h1 id="订阅机制和定时消息"><a href="#订阅机制和定时消息" class="headerlink" title="订阅机制和定时消息"></a>订阅机制和定时消息</h1><h2 id="发布订阅的基本概念"><a href="#发布订阅的基本概念" class="headerlink" title="发布订阅的基本概念"></a>发布订阅的基本概念</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648012647063-479df7f2-a993-4ee2-b722-36e22fa8ceb3.png"></p><p>发布订阅模式能够实现一个queue被多个消费者消费。在RocketMQ其实没有专门做发布订阅的实现，但是提供了另外的实现。</p><p>了解发布订阅前，需要了解一下消息订阅的两种模式：</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648012807300-ead98630-602a-4591-8ac3-7003785f3421.png"></p><p>但是，在RocketMQ中两种方式的具体实现，都是消费端主动从Broker拉取消息。只是说Push模式添加了个监听器，但实际上消息来了还是由消费端pull，是伪push。</p><p>代码示例<code>PullConsumer.java</code></p><p>pull客户端比较容易出错的地方在于要自己手动控制进度的提交，设置不好，容易出现重复消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PullConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME_SERVER_ADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建消费者（Pull）对象</span><br>        <span class="hljs-type">DefaultMQPullConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPullConsumer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        consumer.setNamesrvAddr(NAME_SERVER_ADDR);<br>        consumer.start();<br>        <span class="hljs-comment">// 3. 获取到对于topic的queue列表</span><br>        Set&lt;MessageQueue&gt; messageQueues = consumer.fetchSubscribeMessageQueues(<span class="hljs-string">&quot;TopicTest&quot;</span>);<br>        Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 4. 循环遍历</span><br>                <span class="hljs-keyword">for</span> (MessageQueue messageQueue : messageQueues) &#123;<br>                    <span class="hljs-comment">// 5. 获取读取位置</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> consumer.fetchConsumeOffset(messageQueue, <span class="hljs-literal">true</span>);<br>                    <span class="hljs-comment">// 6. 从指定位置取queue中的消息，每次最多10条。  如果没有则阻塞等待</span><br>                    <span class="hljs-type">PullResult</span> <span class="hljs-variable">pullResult</span> <span class="hljs-operator">=</span> consumer.pullBlockIfNotFound(messageQueue, <span class="hljs-literal">null</span>, offset, <span class="hljs-number">10</span>);<br>                    <span class="hljs-comment">// 7. 存储Offset，客户端每隔5s会定时刷新到Broker()</span><br>                    System.out.println(pullResult.getNextBeginOffset());<br>                    consumer.updateConsumeOffset(messageQueue, pullResult.getNextBeginOffset());<br>                    <span class="hljs-comment">// 8. 遍历结果</span><br>                    <span class="hljs-keyword">if</span> (pullResult.getPullStatus() == PullStatus.FOUND) &#123;<br>                        List&lt;MessageExt&gt; messageExtList = pullResult.getMsgFoundList();<br>                        <span class="hljs-keyword">for</span> (MessageExt messageExt : messageExtList) &#123;<br>                            System.out.printf(<span class="hljs-string">&quot;线程：%-25s 接收到新消息 %s --- %s %n&quot;</span>, Thread.currentThread().getName(), messageExt.getTags(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-number">1000L</span>, <span class="hljs-number">1000L</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以实际使用中pull的方式还是比较少的，常用的方式是用push，push是基于pull上封装的，所以使用起来比较方便，只需要注册一个监听器上去就OK。如果不是有特殊的需要，可以直接用push方法</p><h2 id="RocketMQ订阅模式实现原理"><a href="#RocketMQ订阅模式实现原理" class="headerlink" title="RocketMQ订阅模式实现原理"></a>RocketMQ订阅模式实现原理</h2><h3 id="push-推模式"><a href="#push-推模式" class="headerlink" title="push 推模式"></a>push 推模式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648013250358-8a1c0e21-d2c8-4e1f-ac4c-3b43c5fbe9ae.png"></p><p>在push模式下，框内的代码已经由RocketMQ帮我们完成了。我们只需要指定订阅主题、 注册监听、以及业务处理代码就OK了</p><h3 id="pull-拉模式"><a href="#pull-拉模式" class="headerlink" title="pull 拉模式"></a>pull 拉模式</h3><p>Pull方式里面，取消息的过程就需要自己实现。</p><p>基本步骤就是，首先通过消费的topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取得开始offset，直到取完为止，再换另一个MessageQueue。</p><h2 id="订阅模式的使用"><a href="#订阅模式的使用" class="headerlink" title="订阅模式的使用"></a>订阅模式的使用</h2><blockquote><p>官方示例：<a href="https://rocketmq.apache.org/docs/broadcast-example/">https://rocketmq.apache.org/docs/broadcast-example/</a></p></blockquote><p>BroadcastConsumer 需要最少启动两个才能更好的看到效果</p><ul><li>MessageModel.BROADCASTING 广播消费模式，所有订阅了同一个主题的消费者都会收到相同的消息</li><li>MessageModel.CLUSTERING   集群消费模式，此集群不是指集群环境中的集群，但概念相同，即可实现消息的负载均衡。当有多个消费者订阅了相同的主题时，同一条消息只会有一个消费者消费</li></ul><p>代码示例：BroadcastConsumer.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 3. 设置消息模式，默认是CLUSTERING</span><br><span class="hljs-comment">         * MessageModel.BROADCASTING 广播消费模式</span><br><span class="hljs-comment">         * MessageModel.CLUSTERING   集群消费模式</span><br><span class="hljs-comment">         */</span><br>        consumer.setMessageModel(MessageModel.BROADCASTING);<br></code></pre></td></tr></table></figure><p>有一点比较困惑的就是，消费模式是由消费者端设置的。那么如果启动两个消费者，一个设置为广播模式，一个设置为集群消费模式，会出现什么样的效果呢？</p><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>定时消息是指消息发送到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等到特定的事件后才能被消费。</p><p>如果要支持任意的时间精度，再Broker层面，必须要做消息排序，如果再涉及持久化，那么消息排序就会不可避免地产生巨大性能开销。</p><p>RocketMQ支持定时消息，但是不支持任意时间精度，支持特定的level，例如 定时5s，10s ，1m等。这么做的目的是提高性能。</p><h3 id="延迟级别"><a href="#延迟级别" class="headerlink" title="延迟级别"></a>延迟级别</h3><p>在broker端，可以配置延迟级别（level）对应延迟时间的关系，RocketMQ也提供了默认的关系。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648014222577-1531f656-e8a7-434d-aa09-3d4f8dfbd513.png">Producer会用到这个延迟级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以在broker服务器端自行配置messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br>            message.setDelayTimeLevel(<span class="hljs-number">3</span>);<span class="hljs-comment">//这样设置代表着消息发送到broker之后 10s后才能被consumer消费。</span><br></code></pre></td></tr></table></figure><p>Consumer端没有需要修改的地方。</p><p>这种延迟级别的概念可以说是相当奇怪了，为什么会有这么奇怪的实现呢，与它底层实现有关。</p><h3 id="发送逻辑"><a href="#发送逻辑" class="headerlink" title="发送逻辑"></a>发送逻辑</h3><p>首先，对于定时消息的存储，每个等级的消息属于不同的queue，比如等级1的消息会被放到一个queue。这个是有逻辑调整的，与上面的所讲的queue有所不同，存放定时任务的queue和普通消息的queue是分开的。每一个延迟队列都会有topic信息来保持对应关系。</p><p>简单来讲，具体实现只是多了一个时间计算的过程。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648014725243-43c74e22-26ef-4c8e-9067-940dc85e8d74.png"></p><p>源码实现在：ScheduleMessageService.java </p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><blockquote><p>官方示例：<a href="https://rocketmq.apache.org/docs/schedule-example/">https://rocketmq.apache.org/docs/schedule-example/</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledMessageProducer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME_SERVER_ADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException, RemotingException, MQBrokerException, UnsupportedEncodingException &#123;<br>        <span class="hljs-comment">// 1. 创建生产者对象</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        producer.setNamesrvAddr(NAME_SERVER_ADDR);<br><br>        <span class="hljs-comment">// 3. 启动生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello scheduled message &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SS&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, content.getBytes(RemotingHelper.DEFAULT_CHARSET));<br><br>            <span class="hljs-comment">// 4. 设置延时等级，此消息将在10秒后传递给消费者</span><br>            <span class="hljs-comment">// 可以在broker服务器端自行配置messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br>            message.setDelayTimeLevel(<span class="hljs-number">3</span>);<br><br>            <span class="hljs-comment">// 5. 发送消息</span><br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> producer.send(message);<br><br>            System.out.printf(<span class="hljs-string">&quot;发送结果：%s%n&quot;</span>, result);<br>            TimeUnit.MILLISECONDS.sleep(RandomUtils.nextInt(<span class="hljs-number">300</span>, <span class="hljs-number">800</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// 6. 停止生产者</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h1 id="批量消息与事务消息"><a href="#批量消息与事务消息" class="headerlink" title="批量消息与事务消息"></a>批量消息与事务消息</h1><p>这两个特性对于业务需求是很有必要的。</p><h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>为什么使用批量消息？</p><p>在很多调优的时候，比如数据库批量处理，有些请求进行合并发送等都是类似批量的实现。RocketMQ批量发送也是为了追求性能，将数据堆积到MQ中，特别在消息数量特别大的时候，批量效果就更加明显了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchMessageProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException, RemotingException, MQBrokerException, UnsupportedEncodingException &#123;<br>        <span class="hljs-comment">// 1. 创建生产者对象</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 启动生产者</span><br>        producer.start();<br><br>        List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello batch message &quot;</span> + i;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, content.getBytes(RemotingHelper.DEFAULT_CHARSET));<br><br>            messages.add(message);<br>        &#125;<br>        <span class="hljs-comment">// 5. 发送消息</span><br>        <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> producer.send(messages);<br>        System.out.println(<span class="hljs-string">&quot;消息已发送：&quot;</span> + result);<br><br>        <span class="hljs-comment">// 6. 停止生产者</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发送的时候不再是一条一条发送，而是发送一个集合。</p><p>消费者方面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchMessageConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException &#123;<br><br>        <span class="hljs-comment">// 1. 创建消费者（Push）对象</span><br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 订阅对应的主题和Tag</span><br>        consumer.subscribe(<span class="hljs-string">&quot;TopicTest&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-comment">// 4. 设置消息批处理数量，即每次最多获取多少消息，默认是1</span><br>        consumer.setConsumeMessageBatchMaxSize(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 5. 注册接收到Broker消息后的处理接口</span><br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 设置消息批处理数量后，list中才会有多条，否则每次只会有一条</span><br>                    <span class="hljs-keyword">for</span> (MessageExt messageExt : list) &#123;<br>                        System.out.printf(<span class="hljs-string">&quot;线程：%-25s 接收到新消息 --- %s %n&quot;</span>, Thread.currentThread().getName(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET));<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 6. 启动消费者(必须在注册完消息监听器后启动，否则会报错)</span><br>        consumer.start();<br><br>        System.out.println(<span class="hljs-string">&quot;已启动消费者&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键在于使用<code>consumer.setConsumeMessageBatchMaxSize(10);</code> 设置每次获取消息的数量。</p><p>RocketMQ默认创建4个Queue，所以消费的时候会创建4个线程来消费。</p><p>批量处理数据可以大大提高处理效率，但是也有它的使用限制。</p><h3 id="使用批量消息的限制"><a href="#使用批量消息的限制" class="headerlink" title="使用批量消息的限制"></a>使用批量消息的限制</h3><blockquote><p>官方示例：<a href="https://rocketmq.apache.org/docs/batch-example/">https://rocketmq.apache.org/docs/batch-example/</a></p></blockquote><ul><li>同一批次的消息应该具有相同主题（topic），相同的消息配置（tag等）</li><li>不支持延迟消息</li><li>建议一个批量消息大小最好不要超过1MB。因为使用的是长连接，所以如果传输数据时间过长，会阻塞其他的功能。1MB是官方建议。</li></ul><h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>什么是事务消息？</p><p>RocketMQ的事务消息，是指Producer端消息发送时间和本地事务事件，同时成功或失败。本地入DB失败，RocketMQ那边也需要回滚 这样的情况。</p><h3 id="事务消息设计"><a href="#事务消息设计" class="headerlink" title="事务消息设计"></a>事务消息设计</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648021479871-e196a2df-18d1-4fa5-a504-3a6fee3c98da.png"></p><p>当发送消息的时候会</p><ol><li>先发送Half消息，MQ Server接收到Half消息，存储在MQ中</li><li>如果消息发送成功，会返回发送成功的回执给到MQ发送方，表示MQ接收消息成功</li><li>MQ发送方就会执行本地事务</li><li>本地事务如果成功，就会执行MQ事务的提交，MQ事务是否提交成功也会返回一个回执给到MQ发送方，MQ发送方根据这个回执来决定操作</li><li>如果MQserver 没有收到MQ发送方关于本地事务的commite&#x2F;rollback的消息，那么MQ Server会主动的回查数据状态，默认60s，可以配置修改</li><li>这个时候MQ发送方应该有操作逻辑去查询本地事务的状态</li><li>然后再去通知MQServer提交事务。 MQServer那边如果接收到了commit，才会去投递消息，否则就会删除消息。</li></ol><p>这个设计注意的点就是第5步，当没有收到commit&#x2F;rollback，MQ会主动会查事务状态。</p><p>使用方面：需要实现TransactionListenr中的两个方法，来检查与执行本地事务方法，并且 设置上</p><p> <code>producer.setTransactionListener(transactionListenerImpl);</code>然后 <code>producer.setTransactionListener(transactionListenerImpl);</code>发送事务消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionMessageProducer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事务消息监听实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">TransactionListener</span> <span class="hljs-variable">transactionListenerImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionListener</span>() &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在发送消息成功时执行本地事务</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> arg producer.sendMessageInTransaction的第二个参数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 返回事务状态</span><br><span class="hljs-comment">         * LocalTransactionState.COMMIT_MESSAGE：提交事务，提交后broker才允许消费者使用</span><br><span class="hljs-comment">         * LocalTransactionState.RollbackTransaction：回滚事务，回滚后消息将被删除，并且不允许别消费</span><br><span class="hljs-comment">         * LocalTransactionState.Unknown：中间状态，表示MQ需要核对，以确定状态</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>            <span class="hljs-comment">// TODO 开启本地事务（实际就是我们的jdbc操作）</span><br><br>            <span class="hljs-comment">// TODO 执行业务代码（插入订单数据库表）</span><br>            <span class="hljs-comment">// int i = orderDatabaseService.insert(....)</span><br>            <span class="hljs-comment">// TODO 提交或回滚本地事务(如果用spring事务注解，这些都不需要我们手工去操作)</span><br><br>            <span class="hljs-comment">// 模拟一个处理结果</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 模拟返回事务状态</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">switch</span> (index) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    System.out.printf(<span class="hljs-string">&quot;本地事务回滚，回滚消息，id:%s%n&quot;</span>, msg.getKeys());<br>                    <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                    <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;事务提交，消息正常处理&quot;</span>);<br>                    <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），</span><br><span class="hljs-comment">         * 由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 返回事务状态</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(MessageExt msg)</span> &#123;<br>            <span class="hljs-comment">// 根据业务，正确处理： 订单场景，只要数据库有了这条记录，消息应该被commit</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">transactionId</span> <span class="hljs-operator">=</span> msg.getTransactionId();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> msg.getKeys();<br>            System.out.printf(<span class="hljs-string">&quot;回查事务状态 key:%-5s msgId:%-10s transactionId:%-10s %n&quot;</span>, key, msg.getMsgId(), transactionId);<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;id_5&quot;</span>.equals(key)) &#123; <span class="hljs-comment">// 刚刚测试的10条消息， 把id_5这条消息提交，其他的全部回滚。</span><br>                System.out.printf(<span class="hljs-string">&quot;回查到本地事务已提交，提交消息，id:%s%n&quot;</span>, msg.getKeys());<br>                <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;未查到本地事务状态，回滚消息，id:%s%n&quot;</span>, msg.getKeys());<br>                <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, IOException &#123;<br>        <span class="hljs-comment">// 1. 创建事务生产者对象</span><br>        <span class="hljs-comment">// 和普通消息生产者有所区别，这里使用的是TransactionMQProducer</span><br>        <span class="hljs-type">TransactionMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionMQProducer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 设置事务监听器</span><br>        producer.setTransactionListener(transactionListenerImpl);<br><br>        <span class="hljs-comment">// 4. 启动生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello transaction message &quot;</span> + i;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;id_&quot;</span> + i, content.getBytes(RemotingHelper.DEFAULT_CHARSET));<br><br>            <span class="hljs-comment">// 5. 发送消息(发送一条新订单生成的通知)</span><br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> producer.sendMessageInTransaction(message, i);<br><br>            System.out.printf(<span class="hljs-string">&quot;发送结果：%s%n&quot;</span>, result);<br>        &#125;<br><br>        System.in.read();<br>        <span class="hljs-comment">// 6. 停止生产者</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="事务消息使用约束"><a href="#事务消息使用约束" class="headerlink" title="事务消息使用约束"></a>事务消息使用约束</h3><ul><li>事务不支持定时和批量</li><li>为了避免一个消息被多次检查，导致半数队列消息堆积，RokcetMQ限制了单个消息的默认检查次数为15次，通过修改broker配置文件中的transactionCheckMax参数进行调整</li><li>特定的时间之后才回查检查事务，通过Broker配置文件参数<code>transactionTimeout</code>或用户配置<code>CHECK_IMMUNITY_TIME_IN_SECONDS</code>调整时间</li><li>一个事务消息可能被检查或消费多次</li><li>提交过的消息重新放到用户目标topic主题可能会失败</li><li>事务消息的生产者ID不能与其他消息类型消息的生产者ID共享，做了事务消息，就不能去做别的了</li></ul><h3 id="事务消息的状态"><a href="#事务消息的状态" class="headerlink" title="事务消息的状态"></a>事务消息的状态</h3><ul><li>TransactionStatus.CommitTransaction：提交事务，允许消费者消费这个事务</li><li>TranscationStatus.RollbackTransaction：回滚事务，消息将会被删除或不再允许消费</li><li>TransactionStatus.Unknown：中间状态，MQ需要重新检查来确认状态</li><li>不返回：也是会回查</li></ul><h1 id="可视化管理界面"><a href="#可视化管理界面" class="headerlink" title="可视化管理界面"></a>可视化管理界面</h1><p>rocketmq默认不带可视化控制台，需要去单独编译一个工具 <a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a>  </p><ol><li><p>git clone源码<code> git clone https://github.com/apache/rocketmq-externals</code></p></li><li><p>切换版本 <code>git checkout rocketmq-console-1.0.0</code></p></li><li><p>编译为jar <code>mvn clean package -Dmaven.test.skip=true</code></p></li><li><p>启动</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">jar包在target目录下面，你可以放在一台服务器上面运行</span><br>java -jar rocketmq-console-ng-1.0.0.jar --server.port=8081--rocketmq.config.namesrvAddr=192.168.100.242:9876<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--server.port springboot内置tomcat的端口号，默认8080；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--rocketmq.config.namesrvAddr  nameserver的地址</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">![](https://cdn.nlark.com/yuque/0/2022/png/1980660/1648030025836-c97b50e6-f8ee-45bf-8e0a-7f8d5cee1ec9.png)、这样就会启动RocketMQ的控制台。&lt;u&gt;图中参数间没空格，自行改一下&lt;/u&gt;![](https://cdn.nlark.com/yuque/0/2022/png/1980660/1648030088855-1c746931-8e37-4483-a20b-df5d88a2480d.png)可以在github 的看到这个控制界面的使用文档。这里就不占用篇幅了。</code></pre>]]></content>
    
    
    <categories>
      
      <category>middileware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>middileware</tag>
      
      <tag>mq</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis简介</title>
    <link href="/2024/07/10/redis/"/>
    <url>/2024/07/10/redis/</url>
    
    <content type="html"><![CDATA[<p>Redis是一款C语言编写的开源的、支持网络、可基于内存也可以持久化的日志型、K-V数据库，提供多语言支持的API。<br>本质是一款C&#x2F;S应用软件程序，特点是使用简单、性能强悍、应用场景丰富。<br>本文章主要以介绍了解Redis结构为主，并没有深入分析。</p><h1 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637576877208-cb670dfc-87e6-465e-8efd-7bb7242297d3.png#clientId=uf2c27fc7-7f22-4&from=paste&height=342&id=ud5fb02d1&originHeight=684&originWidth=1883&originalType=binary&ratio=1&size=433502&status=done&style=none&taskId=u6af71f68-53d4-41e3-83f5-248caa4bc6d&width=941.5" alt="image.png"></p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>7中主流结构：String，List，Set，Sorted Set，Hash，GEO，Stream</p><p>**String **，是一种简单的K-V类型，value不仅是String，也可以是数字。时使用场景：微博数，粉丝数（常规计数）<br>常用命令：，<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637577953120-7d931d8c-bd5b-4269-9643-e736b8302f80.png#clientId=uf2c27fc7-7f22-4&from=paste&height=236&id=u7dffc2e8&originHeight=472&originWidth=1263&originalType=binary&ratio=1&size=190314&status=done&style=none&taskId=u6678dc6f-34ee-4c5d-a474-ee40f0d86cb&width=631.5" alt="image.png"><br><strong>List</strong>，链表，基础且典型的一种数据结构，使用场景：关注列表，粉丝列表<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637585375451-1bf4ba6c-4e97-4adb-a091-fcec0ddbc2bd.png#clientId=uf2c27fc7-7f22-4&from=paste&height=255&id=u2820b344&originHeight=509&originWidth=1609&originalType=binary&ratio=1&size=330516&status=done&style=none&taskId=u8e6c5d2d-7739-4819-a11e-0ad97972504&width=804.5" alt="image.png"><br><strong>Set</strong>，集合，也是典型的数据结构，用于存储不重复的数据。使用场景：共同关注，共同好友<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637585603750-20c422ff-d24e-4d85-9759-652ecbaf2f2e.png#clientId=uf2c27fc7-7f22-4&from=paste&height=254&id=u55db32e4&originHeight=508&originWidth=1724&originalType=binary&ratio=1&size=237990&status=done&style=none&taskId=uf411722b-b5c9-45ed-9190-6ab39ba1805&width=862" alt="image.png"><br><strong>Sorted Set</strong>，数据结构和Set一样，多一个自动排序的实现，允许用户通过额外的参数（优先级）来为成员排序，且是插入有序的，自动排序<br>。使用场景：排行榜<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637585959388-1962420d-5842-4b37-ae4e-19e6889e84c9.png#clientId=uf2c27fc7-7f22-4&from=paste&height=227&id=ub2158b9a&originHeight=454&originWidth=1673&originalType=binary&ratio=1&size=302604&status=done&style=none&taskId=u5ec3ca9b-bf37-4a94-8e80-25ac31e78be&width=836.5" alt="image.png"><br><strong>Hash，</strong>是一个String类型的Field和Value的映射表，使用场景：存储部分变更数据，比如用户表数据<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637586055315-10823879-ba53-4e47-b82d-092c6d2a7dcd.png#clientId=uf2c27fc7-7f22-4&from=paste&height=189&id=u2031667a&originHeight=377&originWidth=1618&originalType=binary&ratio=1&size=222196&status=done&style=none&taskId=ud6555bed-9e6a-454b-8680-828cbc7a39e&width=809" alt="image.png"><br><strong>GEO</strong>，地理位置，使用场景：LBS应用开发；3.2版本后新增支持。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637586310288-27ca4c2a-fa33-42dd-ae25-c77e98969aab.png#clientId=uf2c27fc7-7f22-4&from=paste&height=357&id=uabfab89b&originHeight=714&originWidth=1806&originalType=binary&ratio=1&size=673720&status=done&style=none&taskId=u21b66b00-ece7-4437-b8bb-d2293f6fba1&width=903" alt="image.png"><br><strong>Stream</strong>，流，使用场景：类似MQ使用方式；5.0版本后新增支持，可以把Stream理解为Queue.<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637586475477-6e18d5e5-549a-416e-a173-9d93f43c50a4.png#clientId=uf2c27fc7-7f22-4&from=paste&height=280&id=uc7e3c54a&originHeight=559&originWidth=1812&originalType=binary&ratio=1&size=338235&status=done&style=none&taskId=u27e1a0fe-ff12-43b5-9e4e-ce693455426&width=906" alt="image.png"><br>这里着重介绍以下Stream这个数据结构，其实也是key-value的存储形式，value使用类似Queue的方式存储，同一个key下可能有很多个value，这些value通过ID去区分，通过XADD命令往key里面添加value时，不指定ID的话，redis可以帮忙生成（时间戳+序号）；<br>XGROUP命令帮助我们创建消费者分组。在多个消费者的场景下，如果使用XREAD来进行读取操作有可能出现重复消费的情况，如果是同一个消费组的消费者将不会出现重复消费的情况，消费者读取的时候除了要指定StreamKey之外还要指定所属分组Group，分组会记录消费的情况，类似kafka的分组消费，保证了不重复消费。这时候使用的命令就不是XREAD，而是XREADGROUP，使用这个命令还需要我们手动使用XACK来回复确认，不然就会进入pending的列表中，长时间的pending后仍然没有ack，那么Redis就会重新分派，并且消费者需要自己主动申请（XCLAIM）去消费这个pending的信息。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637670255215-63e4a322-c6e9-448d-92dc-7122abf1431f.png#clientId=u12408a10-52f9-4&from=paste&height=402&id=uae84edc7&originHeight=804&originWidth=1913&originalType=binary&ratio=1&size=941455&status=done&style=none&taskId=u4e44b9f8-c9ca-4745-a2ca-879f3cdd1e4&width=956.5" alt="image.png"></p><hr><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis的数据都放在内存中，如果没有配置持久化，redis重启之后数据就丢失了，开启持久化功能，数据就能被保存到磁盘，当Redis重启后，可以从磁盘中恢复数据。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637674963121-45c6008a-eb93-41d8-a032-87b0b2454014.png#clientId=u12408a10-52f9-4&from=paste&height=183&id=u07de6b9c&originHeight=366&originWidth=1119&originalType=binary&ratio=1&size=47171&status=done&style=none&taskId=u3d1bc320-50e9-4a0d-89f5-2b5c680c975&width=559.5" alt="image.png"></p><h2 id="持久化的方式"><a href="#持久化的方式" class="headerlink" title="持久化的方式"></a>持久化的方式</h2><ul><li>RDB：在指定时间间隔后对数据进行快照存储</li><li>AOF：append only file，记录每次对服务器写的操作，当服务器重启时会重新执行这些命令来回复原始数据。</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>客户端可以使用BGSAVE或者SAVE命令来完成快照的创建。</p><ul><li>BGSAVE调用fork来创建一个子线程，子线程负责将快照写入磁盘，父进程继续处理请求。</li><li>SAVE执行过程时，不会响应别的命令请求。</li></ul><p>在redis.conf文件中可以配置SAVE命令的选项。当在规定时间内，Redis发生写的个数满足条件会触发BGSAVE命令<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637676145668-0f2e00c3-8745-4c77-8cf7-e9769bd27e7f.png#clientId=u12408a10-52f9-4&from=paste&height=242&id=u8bc30e4a&originHeight=483&originWidth=1553&originalType=binary&ratio=1&size=271574&status=done&style=none&taskId=u742ffce7-43b4-4f28-85e8-79ee589d63c&width=776.5" alt="image.png"></p><h4 id="RDB的优缺点"><a href="#RDB的优缺点" class="headerlink" title="RDB的优缺点"></a>RDB的优缺点</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637676242984-a9f3b1a6-1fe2-43e5-8e79-832bdfb29658.png#clientId=u12408a10-52f9-4&from=paste&height=351&id=u8768c3f5&originHeight=701&originWidth=2069&originalType=binary&ratio=1&size=474215&status=done&style=none&taskId=uc68cdcce-f586-4aa8-90b1-9f588bd15fe&width=1034.5" alt="image.png"></p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>开启AOF持久化：appendonly yes<br>AOF的策略：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637676379618-5a525eec-92dc-400c-a58e-264890e1dd6a.png#clientId=u12408a10-52f9-4&from=paste&height=245&id=ud1bbfef2&originHeight=490&originWidth=1450&originalType=binary&ratio=1&size=386659&status=done&style=none&taskId=u57fb0ed2-38af-4448-b8fb-6ae2b2dd7bb&width=725" alt="image.png"></p><h4 id="AOF的优缺点"><a href="#AOF的优缺点" class="headerlink" title="AOF的优缺点"></a>AOF的优缺点</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637676433174-af55896d-3c06-4713-baee-039ad81e9479.png#clientId=u12408a10-52f9-4&from=paste&height=217&id=uabcd8c52&originHeight=433&originWidth=2033&originalType=binary&ratio=1&size=242600&status=done&style=none&taskId=u499e2a73-2758-4b0e-bfc6-1bb675b5143&width=1016.5" alt="image.png"></p><hr><h1 id="内存管理："><a href="#内存管理：" class="headerlink" title="内存管理："></a>内存管理：</h1><p>redis将数据 主要存储在内存中，所以在redis设计时对数据类型进行了内存限制与分配</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>不同的数据类型会被限制成不同的大小：</p><ul><li>String类型： 一个String类型的value最大可以存储512M</li><li>List类型： list的元素个数最多位2^32-1个，也就是4294967295个</li><li>Set类型：元素个数最多为2^32-1个</li><li>Hash类型：键值对个数最多为2^32-1个</li></ul><p>redis可以通过配置文件来对内存进行控制<br>#最大内存控制<br>maxmemory 最大内存阈值8<br>maxmemory-policy 到达阈值的执行策略<br>这个执行策略具体有哪些在后续会补充。见<a href="#p2qkq">内存回收策略</a></p><h2 id="内存压缩"><a href="#内存压缩" class="headerlink" title="内存压缩"></a>内存压缩</h2><p>redis在存储数据的时候会对数据进行内存压缩，并不是说10M的数据存储在内存中就是10M。压缩的策略可以通过配置文件进行配置，如下图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637828891910-b959de63-971b-403a-9eb0-2474a04d8dcf.png#clientId=u4d6c29fb-f2ec-4&from=paste&height=579&id=uba25ca91&originHeight=579&originWidth=1230&originalType=binary&ratio=1&size=380667&status=done&style=none&taskId=u9a0ec041-0dd5-4df1-bd4c-61065ccd282&width=1230" alt="image.png"><br>hash-max-zipmap-entries 512<br> 表示最多对512个数据进行压缩，超过这个数量就不会进行压缩，因为压缩会消耗机器性能。<br>list-max-ziplist-entries 512<br>表示list中最多对512个数据进行压缩<br>list-max-ziplist-value<br>表示list里面每个value如果被压缩 最大值为64byte，超过的数据也不会被压缩<br>关键是 超过了压缩范围，包括数量和大小，溢出后不会进行压缩</p><h2 id="过期数据处理策略"><a href="#过期数据处理策略" class="headerlink" title="过期数据处理策略"></a>过期数据处理策略</h2><p>redis很少会出现数据溢出或是数据存储满了的情况，原因就是过期数据处理策略。<br>分为两种策略：</p><ul><li>主动处理<br>redis主动出发检测key是否过期，每秒执行10次，具体过程：<ol><li>从设置了过期时间的密钥中随机抽取20个密钥</li><li>删除找到得密钥中已过期得</li><li>如果超过25%得密钥已过期，就再次执行第一步</li></ol></li><li>被动处理</li></ul><p>在每次访问key的时候，会先判断时候超时，如果超时就会立刻删掉，不会返回。</p><h3 id="数据恢复阶段过期数据的处理策略"><a href="#数据恢复阶段过期数据的处理策略" class="headerlink" title="数据恢复阶段过期数据的处理策略"></a>数据恢复阶段过期数据的处理策略</h3><p>这是一个需要注意的点。在数据恢复阶段，过期数据的处理策略会有所不同。</p><ul><li>RDB方式<br>过期的key不会持久化到文件中；</li></ul><p>载入时过期的key会通过redis的主动和被动方式清理掉。</p><ul><li>AOF方式<br>每次遇到过期的key时，会追加一条del 命令到AOF文件中，就是说只要我们顺序执行AOF命令文件就会删除过期的key</li></ul><p>*注意 过期使用的时间是与计算机本身的时间有直接关联的。</p><h2 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h2><p>即使对过期数据进行完处理，还是有可能出现内存不足的情况，这时候就需要执行内存回收策略，像JVM的GC一样。<br>配置文件中设置：maxmemory-policy <strong>noeviction</strong><br>动态调整：config set maxmemory-policy <strong>noeviction</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637831067839-2efbe367-fd0a-470f-a84d-7961ff0c9d42.png#clientId=u416e10e2-eb49-4&from=paste&height=598&id=uc1c0d294&originHeight=598&originWidth=1647&originalType=binary&ratio=1&size=518064&status=done&style=none&taskId=u453c9c53-0abe-421f-acae-9f80660a9f9&width=1647" alt="image.png"></p><h3 id="LRU算法（Least-recently-used-最近最少使用）"><a href="#LRU算法（Least-recently-used-最近最少使用）" class="headerlink" title="LRU算法（Least recently used,最近最少使用）"></a>LRU算法（Least recently used,最近最少使用）</h3><p>根据数据的历史访问记录来进行数据淘汰。注意：Redis中的LRU算法不是完整实现，完整的LRU消耗内存较大，所以Redis只近似实现了。<br>核心思想：如果数据最近被访问过，那么将来被访问的概率会高。<br>实际操作：通过对少量Keys进行取样（50%）,然后回收。<br>通过配置能修改这个取样比例:  maxmemory-samples 5 ；5就代表50%</p><blockquote><p>可以看看别人解读的redis的具体实现 ：<br><a href="https://segmentfault.com/a/1190000017555834">https://segmentfault.com/a/1190000017555834</a></p></blockquote><h3 id="LFU-Least-Frequently-Used，根据数据的历史访问频率（次数）来淘汰数据"><a href="#LFU-Least-Frequently-Used，根据数据的历史访问频率（次数）来淘汰数据" class="headerlink" title="LFU(Least Frequently Used，根据数据的历史访问频率（次数）来淘汰数据)"></a>LFU(Least Frequently Used，根据数据的历史访问频率（次数）来淘汰数据)</h3><ul><li>核心思想：如果数据过去被访问多次，那么将来被访问的频率就更高，被删除的几率就应该小</li><li>Redis实现的是近似的实现，每次对KEY进行访问时，用<strong>基于概率的对数计数器</strong>来记录访问次数，同时这个计数器会随着时间推移变小。</li><li>在启用LFU算法后，可以使用热点数据分析功能（redis-cli –hotkeys）</li></ul><p>这个算法实现依靠Morris counter算法:<br><a href="https://en.wikipedia.org/wiki/Approximate_counting_algorithm">https://en.wikipedia.org/wiki/Approximate_counting_algorithm</a></p><p>这两个算法具体实现，可以自行去搜索学习，不是本次redis介绍的重点。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>cache</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程基础</title>
    <link href="/2024/06/21/concurentProgrammingFoundation/"/>
    <url>/2024/06/21/concurentProgrammingFoundation/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638544376984-71b7ba61-0f53-4ebf-b7be-9472a54fc65b.png#clientId=u705a002e-0033-4&from=paste&height=759&id=ud15506e9&originHeight=759&originWidth=1315&originalType=binary&ratio=1&rotation=0&showTitle=false&size=314311&status=done&style=none&taskId=u8b00f397-6fd7-4c99-84d6-4ae45af4fb0&title=&width=1315" alt="image.png"><br>定义了6种状态：<code>java.lang.Thread.State</code></p><ol><li>New：尚未启动的线程的线程状态，线程被创建但是并没有开始执行。</li><li>Runnable：可运行线程的线程状态，等待CPU状态</li><li>Blocked：线程阻塞等待监视器锁定的线程状态，就是没抢到锁。处于synchronized同步代码块或者方法中被阻塞等待锁</li><li>Waiting：等待线程的线程状态，等待被其他线程唤醒后继续执行，依赖另一个线程调度的。下列不带超时的方式：<code>Object.wait、Thread.join、LockSupport.park</code></li><li>Timed Waiting：具有指定等待时间的等待线程的线程状态。带有超时时间的方式：<code>Thread.sleep()，Object.wait()，Thread.join()，LockSupport.parkNanos() ，LockSupport.parkUtil()</code> 在超过了等待的时间后要么继续往下执行，要么抛出异常。</li><li>Terminated：终止线程的线程状态。线程正常完成执行或者出现异常</li></ol><p>代码地址：&#x2F;&#x2F;todo</p><h1 id="线程中止方式"><a href="#线程中止方式" class="headerlink" title="线程中止方式"></a>线程中止方式</h1><p>了解完线程的几种状态之后来看看如何中止一个正在运行的线程。</p><h2 id="不正确的线程中止"><a href="#不正确的线程中止" class="headerlink" title="不正确的线程中止"></a>不正确的线程中止</h2><p><strong>Stop</strong>： 中止线程，并且清除锁的信息，所以可能导致线程安全问题，JDK是不建议使用。并且stop是一刀切，任务可能会被切开成两部分，不能保证任务的原子性。类似的方法还有Destory，但是其实JDK没实现这个方法，白给</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// 增加同步锁，确保线程安全</span><br>    ++i;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 休眠10秒,模拟耗时操作</span><br>      Thread.sleep(<span class="hljs-number">10000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      e.printStackTrace();<br>    &#125;<br>    ++j;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/** * 打印i和j */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot; j=&quot;</span> + j);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 示例3 - 线程stop强制性中止，破坏线程安全的示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">StopThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopThread</span>();<br>    thread.start();<br>    <span class="hljs-comment">// 休眠1秒，确保i变量自增成功</span><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 暂停线程</span><br>    thread.stop(); <span class="hljs-comment">// 错误的终止</span><br>    <span class="hljs-comment">// thread.interrupt(); // 正确终止</span><br>    <span class="hljs-keyword">while</span> (thread.isAlive()) &#123;<br>      <span class="hljs-comment">// 确保线程已经终止</span><br>    &#125; <span class="hljs-comment">// 输出结果</span><br>    thread.print();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638545242677-e348cdc6-0d7f-4a23-b008-8d1d7c8cc371.png#clientId=u705a002e-0033-4&from=paste&height=133&id=u5d1d2c44&originHeight=133&originWidth=812&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80769&status=done&style=none&taskId=u53541834-8221-4c45-a03a-ba946bd1c7b&title=&width=812" alt="image.png"><br>线程的运行受到了其他线程的干扰，同步关键字Synchronized也没有起到应有的效果，线程安全被破坏。</p><h2 id="正确的中止方式"><a href="#正确的中止方式" class="headerlink" title="正确的中止方式"></a>正确的中止方式</h2><p>**Interrupt **</p><ul><li>如果目标线程在调用Object class 的wait()、wait(long)或者wait(long,int)方法、join()、join(long,int)或sleep(long,int)方法被阻塞，那么Interrupt会生效，该线程的中断状态将被清除，抛出InterruptedException异常</li><li>如果目标线程是被I&#x2F;O或者NIO的Channel阻塞，I&#x2F;O操作会被中断或者返回特殊异常值，达到中止线程的目的。（不要过于纠结“终止”和“中止”这里的意思，貌似线程停止之后就启动不了了）</li><li>如果不满足上述条件，就设置此线程的中断状态</li></ul><p>可以将上面Demo3，代码改改，改成Interrupt就能看到能够得到，并且是正确的结果，或者Catch到异常，让程序来处理异常，而不会一刀切，至少保证了线程的安全性。<br><strong>标志位</strong><br>这也是一种常用的手段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 通过状态位来判断 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (flag) &#123; <span class="hljs-comment">// 判断是否运行</span><br>          System.out.println(<span class="hljs-string">&quot;运行中&quot;</span>);<br>          Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;).start();<br>    <span class="hljs-comment">// 3秒之后，将状态标志改为False，代表不继续运行</span><br>    Thread.sleep(<span class="hljs-number">3000L</span>);<br>    flag = <span class="hljs-literal">false</span>;<br>    System.out.println(<span class="hljs-string">&quot;程序运行结束&quot;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意用while循环，因为线程存在伪唤醒问题。</p><h1 id="内存屏障和CPU缓存"><a href="#内存屏障和CPU缓存" class="headerlink" title="内存屏障和CPU缓存"></a>内存屏障和CPU缓存</h1><p>CPU缓存是 CPU为了提高程序运行性能，而产生的一种优化手段。<br>为了提高程序运行的性能，现代CPU在很多方面对程序进行优化。<br>CPU（高速）缓存。为了尽可能避免处理器访问主内存的时间开销，处理器大多会利用缓存。CPU &gt; 内存 &gt;&gt; 硬盘<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638861949579-5a63d3ae-f70c-4ba3-9436-527dec33fe82.png#clientId=u7e471680-c39e-4&from=paste&height=396&id=ub25ebec8&originHeight=396&originWidth=1204&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104779&status=done&style=none&taskId=ucfee4b77-e576-476b-8db0-b59ae7374a1&title=&width=1204" alt="image.png"></p><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><h3 id="CPU多级缓存："><a href="#CPU多级缓存：" class="headerlink" title="CPU多级缓存："></a>CPU多级缓存：</h3><p>目前CPU缓存分为三级缓存</p><ul><li>L1：一级缓存是CPU第一层高速缓存，分为数据缓存与指令缓存。一般服务器CPU的L1 Cache容量在32-4096KB。</li><li>L2：受L1 Cache的容量限制，为了再次提高CPU的运行速度，CPU外部放置高速存储器，即为二级缓存。</li><li>L3：基本上都是内置的。L3 Cache的应用可以进一步降低内存延迟，同时提升大数据量计算时处理器的性能。具有较大L3 Cache的处理器能提供更有效的文件系统缓存行为及较短消息和处理器队列长度。一般是多核共享一个L3 Cache。</li></ul><p>CPU 读取数据顺序为 L1-&gt;L2-&gt;L3-&gt;内存-&gt;外部存储。<br>这些都是硬件层面帮我们做的优化，我们了解为主。</p><hr><p>缓存的使用同时引发了一致性的问题。缓存分级之后很容易导致缓存数据不一致的情况，多CPU读取童谣的数据进行缓存，进行不同运算之后，最终写入主内存时要以哪个CPU为准呢？缓存同步协议就是为了解决这个矛盾</p><h4 id="缓存同步协议"><a href="#缓存同步协议" class="headerlink" title="缓存同步协议"></a>缓存同步协议</h4><p>MESI协议是一个多数CPU厂商都支持的缓存一致性协议。<br>MESI协议规定每条缓存都有个状态位，定义了一下四个状态：</p><ul><li>修改态（Modified）：此缓存已经被修改过（脏行），内容不同于主存，为此cache专有</li><li>专有态（Exclusive）：此缓存内容以主存相同，但不会出现在其他的缓存中</li><li>共享态（Shared）：此缓存内容与主存相同，同时也会出现在其他的缓存中</li><li>无效态（Invalid）：此缓存无效（空行）</li></ul><p>MESI协议约定了：在多CPU协作执行时，单个CPU对缓存数据进行改动，需要通知给其他的CPU，这就意味着CPU需要控制自己的读写操作的同时监听其他CPU发出的通知，来达到缓存一致，达到最终一致。</p><h3 id="运行时指令重排"><a href="#运行时指令重排" class="headerlink" title="运行时指令重排"></a>运行时指令重排</h3><p>CPU做的另一种优化手段，比如：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638866838667-b0dedfee-622b-4dd1-8715-b03454a5e92e.png#clientId=u7e471680-c39e-4&from=paste&height=358&id=u8853630e&originHeight=358&originWidth=1345&originalType=binary&ratio=1&rotation=0&showTitle=false&size=163587&status=done&style=none&taskId=u1f17320a-c103-45ac-8355-20f2ac24178&title=&width=1345" alt="image.png"><br>指令重排的场景：<br>当CPU写缓存的时候发现区块正在被其他CPU占用，为了提高CPU的处理性能，可能将后面的读缓存命令提前执行。<br>当然并非随意重排的，需要遵循as-if-serial语义：不管怎么重排序，<strong>单线程</strong>下（注意！）执行结果不能被改变。编译器、runtime和处理器都必须要遵守as-if-serial语义；数据之间存在依赖关系的操作也不会被做重排。</p><h2 id="优化带来问题"><a href="#优化带来问题" class="headerlink" title="优化带来问题"></a>优化带来问题</h2><ol><li>CPU高速缓存下有问题</li></ol><p>缓存中的数据与主内存并不是实时同步的，各CPU或者CPU核心之间缓存的数据也不是实时同步的。在同一个时间点，各个CPU所看到的同一个内存地址的数据的值可能是不一致的。</p><ol start="2"><li>指令从排序带来的</li></ol><p>虽然需要遵循as-if-serial语义，但是只在单个CPU自己执行的情况下才能保证结果正确。多核多线程下面，指令逻辑没法分辨出因果关系，可能出现乱序执行，导致运行结果错误。</p><hr><p>CPU厂商发现了这些个问题，并做出了解决。处理器提供了两个内存屏障指令（Memory Barrier）用于解决上面的两个问题</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><ul><li>写内存屏障（Store Memory Barrier）：在指令后插入StoreBarrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。这种显示调用的强制写入主内存的时候，CPU就不会因为性能考虑去指令重排.</li><li>读内存屏障（Load Memory Barrier）：在指令前插入LoadBarrier，能让在高速缓存中的数据强制失效，强制从主内存中加载数据。避免了缓存导致的一致性问题。</li></ul><p>这个部分是后面JVM线程安全问题的一点点铺垫。CPU在不断演进，为提供更强的运行能力不变迭代，不同的厂商也为此付出了人力物力成本，最终体现了CPU性能上的差距。</p><hr><h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><blockquote><p>代码：Demo6.java</p></blockquote><p>想实现多个线程的协同，线程执行先后顺序、获取某个线程的执行结果等就会涉及到线程之间的相互通信，分为四类：</p><ol><li><strong>文件</strong></li></ol><p>线程将数据写入到文件系统，然后另外的线程来读取<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638872071084-8ac1221e-af32-475c-90c5-e02f457b9320.png#clientId=u66810570-771d-4&from=paste&height=800&id=uabb2d692&originHeight=800&originWidth=1533&originalType=binary&ratio=1&rotation=0&showTitle=false&size=470410&status=done&style=none&taskId=ua463bc6d-6d3b-4ae1-ab6a-90e3e6d315d&title=&width=1533" alt="image.png"></p><ol start="2"><li><strong>网络</strong></li></ol><p>与文件共享类似 只是载体不同，就不占用篇幅了，后面会有网络开发。</p><ol start="3"><li><strong>变量</strong></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638872130210-17caf68e-aec7-4ffc-b397-97fe58fa1881.png#clientId=u66810570-771d-4&from=paste&height=804&id=ud0c069dc&originHeight=804&originWidth=1574&originalType=binary&ratio=1&rotation=0&showTitle=false&size=415179&status=done&style=none&taskId=u1e68ebc0-ef65-4252-9490-d724e54f6b3&title=&width=1574" alt="image.png"></p><ol start="4"><li><strong>jdk提供的线程协调API</strong></li></ol><p>这个部分是我们需要着重学习的。<br>JDK对于需要多线程协作完成某一人物的场景，已经提供了对应的API支持。典型场景就是生产者-消费者模型，包含了线程阻塞、线程唤醒的应用。<br>想象一下这样的场景：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1638872404609-0012ec1f-d3b3-43cc-9435-707e409d376a.png#clientId=u66810570-771d-4&from=paste&height=593&id=u01c1122f&originHeight=593&originWidth=1637&originalType=binary&ratio=1&rotation=0&showTitle=false&size=254389&status=done&style=none&taskId=u8070b588-08ac-409c-bb99-680155af5e7&title=&width=1637" alt="image.png"><br>通过下面三组api，我们能够实现线程间的调度。</p><ul><li><del>suspend&#x2F;resume</del> ： 由于十分容易写出死锁，已经不建议使用了。suspend执行后不会释放锁，如果在调用suspend之前拿到了锁，调用resume如果要取得这个锁才能执行的话那就白玩了，直接死锁。还有一种情况就是resume在suspend调用之前执行了，那也会死锁。</li><li>wait&#x2F;notify、notifyAll</li></ul><p>这对方法只能由同一个对象锁的持有者线程调用，也就是要写在同步块（<code>Synchronized</code>）里面，否则会抛出<code>IllegalMonitorStateException</code>异常.<br><code>wait</code>方法会导致当前线程等待，加入该对象的等待集合（等待池）中，并且放弃当前持有的对象锁，虽然wait会自动解锁，但是对调用顺序有要求，如果notify提前调用，线程就会一直处于waiting状态</p><ul><li>park&#x2F;unpark</li></ul><p>线程调用park之后就等于在等到“通行许可”，unpark方法为指定线程颁发“通行许可”，只要你持有了通行证随时可以出入，所以调用顺序并不会影响到执行效果。<br>多次调用unpark，再调用park会直接运行，但是不会叠加，如果是多次调用park，也只会拿到一次许可，后续的执行还是会进入等待，所以这个“通行许可”是类似标志位的东西，不含数量特征，多次park 就需要多次unpark。<br>需要注意的是park是不会释放锁的，所以如果你在synchronized里面调用park，并且没有释放锁的话 后面unpark拿不到锁，那就会死锁。<br>具体可以看看到代码。</p><p>这个部分建议配合代码执行，感受一下效果。<br>&#x2F;&#x2F;todo 代码地址</p><h2 id="伪唤醒"><a href="#伪唤醒" class="headerlink" title="伪唤醒"></a>伪唤醒</h2><p>官方建议应该在循环中检查线程等待条件，因为处于等待状态的线程可能会受到错误警报和伪唤醒，导致程序在没有满足结束条件的情况下推出了，这是更低底层的原因导致。所以我们不能用if来判断，而是用while。</p><h1 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>多线程访问共享可变数据时，涉及线程间数据同步的问题。我们并不是任何时候都需要和别人共享数据的，所以线程封闭概念就是这个意思，线程间不共享数据。<br>数据被封闭再各自的线程中，不需要同步，这种通过将数据封闭在线程中从而避免了使用同步技术称为<strong>线程封闭</strong>。<br>线程封闭具体体现有：ThreadLocal、局部变量</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>Java中的一种特殊变量。<br>ThreadLocal是<strong>线程级别变量</strong>，每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的变量，不同线程拥有不同的内容，竞争条件被彻底消除，在并发模式下也是绝对安全的变量。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>ThreadLocal&lt;T&gt; var = new ThreadLocal&lt;T&gt;();</code><br>会自动在每一个线程上创建T的副本，副本之间彼此独立，互不影响。<br>可以用ThreadLocal存储一些参数，以便在线程的多个方法中使用，用来替换方法传参的做法。</p><p>&#x2F;&#x2F;todo 代码Demo7.java</p><p>投机取巧的理解就是，JVM维护了一个Map&lt;Thread，T&gt;，每个线程要使用T时，就用当前线程作为Key去这个Map里面去取值。这个只是一种实现思路，JDK怎么做的 ，我也不知道，没看。</p><h2 id="栈封闭"><a href="#栈封闭" class="headerlink" title="栈封闭"></a>栈封闭</h2><p>局部变量的固有属性之一 就是封闭在线程中，他们只位于执行线程的栈帧中，其他线程无法访问这个栈。学习过JVM的数据存储结构应该就能记得。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>为什么要使用线程池，线程池是不是越多越好？<br>线程在java中是一个对象，同时是操作的系统的资源，线程的创建、销毁是有消耗，是需要时间空间的，频繁地线程操作会消耗系统资源，如果线程的创建时间+销毁时间&gt;执行时间就不合算。<br>java对象占用堆内存，操作系统线程占用系统内存，根据JVM规范，一个线程默认最大栈大小1M，这个栈空间是需要从系统内存中分配的，线程过多将会消耗很多内存。<br>操作系统需要频繁切换线程上下文，每个线程都想自己被运行，都去争抢CPU的调度，影响性能。<br>线程池的目的就是防止线程在上述情况下，消耗过多不必要的资源，同时也方便地控制了线程的数量。</p><h2 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h2><p>由四个组件构成：</p><ol><li>线程池管理器：用于创建与管理线程池，包括创建线程池，销毁线程池，添加任务。</li><li>工作线程：由线程池创建的线程，没有任务是处于等待状态，可以复用以执行任务。</li><li>任务接口：每个任务必须实现的接口，用以供工作线程调度任务的入口，主要规定了任务入口、任务执行状态、任务执行完成后的收尾工作。</li><li>任务队列（仓库）：用于存放尚未能被处理的任务，提供一种缓存机制。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1980660/1605763334438-30491927-5190-4d90-8b3d-1a2c64ba1f5b.png#height=212&id=g7WmF&originHeight=212&originWidth=698&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59174&status=done&style=none&title=&width=698" alt="image.png"></p><h2 id="API-接口定义和实现类"><a href="#API-接口定义和实现类" class="headerlink" title="API 接口定义和实现类"></a>API 接口定义和实现类</h2><p>主要需要关注一下面几个类。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1980660/1605763761529-84c664ee-b7ef-451c-a505-b0093d98a21f.png#height=301&id=LlQQJ&originHeight=301&originWidth=857&originalType=binary&ratio=1&rotation=0&showTitle=false&size=148132&status=done&style=none&title=&width=857" alt="image.png"></p><h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>已经定义了很多的方法<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1639307556045-ec2cc645-6f53-434e-a3d5-1562220fd65d.png#clientId=u73e036d6-412d-4&from=paste&height=818&id=u28189e8c&originHeight=818&originWidth=1677&originalType=binary&ratio=1&rotation=0&showTitle=false&size=692692&status=done&style=none&taskId=u51439a81-c14b-470c-858a-a999ca35fd5&title=&width=1677" alt="image.png"><br>这些方法先看看有个印象，代码使用的时候会更容易理解。</p><hr><h3 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h3><p>除了一次性任务外，更重要的是实现了定时任务、周期任务。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1639308064456-21890e56-9aa1-44b5-a1c8-337a40305a1a.png#clientId=u73e036d6-412d-4&from=paste&height=748&id=u491cb41a&originHeight=748&originWidth=1765&originalType=binary&ratio=1&rotation=0&showTitle=false&size=759063&status=done&style=none&taskId=udc674a86-4be3-42fd-a5c8-319b7890fdc&title=&width=1765" alt="image.png"></h3><p>&#x2F;&#x2F;todo 代码见Demo9.java ，最难理解的是SynChronousQueue，写这个东西的时候我还没理解。</p><p>这里只简单说明一下需要理解的点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、线程池信息： 核心线程数量5，最大数量10，无界队列，超出核心线程数量的线程存活时间：5秒， 指定拒绝策略的</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadPoolExecutorTest1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>testCommon(threadPoolExecutor);<br><span class="hljs-comment">// 预计结果：线程池线程数量为：5,超出数量的任务，其他的进入队列中等待被执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个线程池入参分别由核心线程数，最大线程数，超出核心线程的线程存货时间，时间单位，人物队列大小，拒绝策略。<br>任务数量超过核心线程数量之后，是会被先堆积到任务队列中，然后队列满了才会继续创建线程直到达到最大核心数量，然后执行拒绝策略。所以像上面如果是无界队列的话，是不会达到最大内存的，直到计算资源耗尽。</p><h2 id="线程池工具类-Executors"><a href="#线程池工具类-Executors" class="headerlink" title="线程池工具类-Executors"></a>线程池工具类-Executors</h2><p>虽然我们可以自己实例化线程池，但是大多时候会采用工厂模式来创建，每个公司也有自己的规范，但通常直接实例化的方式已经不提倡了。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>newFixedThreadPool(int nThreads) ：创建一个固定大小、任务队列为无界队列的线程池，最大线程数&#x3D;核心线程数</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>创建一个大小无界的缓冲线程池，任务队列是个同步队列，任务加入到池中，如果池中有空闲线程就用空闲线程去执行，如果没有就创建新线程去执行。池中的线程空闲超过60秒，就会被销毁释放。线程数量跟着任务数量变化。适用于执行耗时较小的异步任务场景，池的核心线程数为0，最大线程数为Integer.MAX_VALUE。</p><h3 id="newSingleThreadPool"><a href="#newSingleThreadPool" class="headerlink" title="newSingleThreadPool"></a>newSingleThreadPool</h3><p>只有一个线程来执行无界任务队列的单一线程池，这个线程池实现确保任务按照加入顺序一个一个依次执行。当唯一的线程因任务异常中止时，会创建一个新的线程来继续执行后面的任务，和newFixedThreadPool(1)的区别在于newSingleThreadPool的池大小是硬编码的，不能再改变。</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>定时执行任务的线程池，核心线程数由参数执行，最大线程数为Integer.MAX_VALUE。</p><p>这里只是简单的做一下介绍，随着jdk更新，api也会变化，最好自己使用的时候进去源码看看。</p><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>原理重点其实在于execute的执行过程：</p><ol><li>是否达到核心线程数量，没达到，就创建一个工作线程来执行任务</li><li>工作队列是否已满，没满就将提交的任务存储到工作队列上</li><li>是否达到线程池最大数量，没达到就创建一个新线程来执行任务。</li><li>最后执行拒绝策列</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1639313822195-df237c79-41db-4893-abe9-80df0f6a59ea.png#clientId=u73e036d6-412d-4&from=paste&height=472&id=u045596ae&originHeight=472&originWidth=1709&originalType=binary&ratio=1&rotation=0&showTitle=false&size=213705&status=done&style=none&taskId=u12703528-309c-4592-95ac-aa4ba53d7dd&title=&width=1709" alt="image.png"><br>线程池的目的就是为了控制线程的数量，那么如何确认合适的线程数量呢？<br>计算型任务：cpu数量的1-2倍<br>IO操作：比计算型需要更多的线程，需要根据IO阻塞的时长进行考量测试觉得，tomcat默认最大线程为200。也可以使用newCachedThreadPool这种自动增减线程数。<br>有个窍门，通过监控cpu的利用率 ，如果能达到80%的使用率，那就比较合理了。</p><p>了解完高并发的组件、api之后，我们将开始学习线程安全部分。这部分的问题其实也是上面指令重排和高速缓存带来的弊端。<br><a href="https://www.yuque.com/xiaoquezai/dtdmru/dfibgv?view=doc_embed">JAVA内存模型</a></p>]]></content>
    
    
    <categories>
      
      <category>concurrent</category>
      
    </categories>
    
    
    <tags>
      
      <tag>concurrent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2024/06/21/networkProgramming/"/>
    <url>/2024/06/21/networkProgramming/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>学习网络编程前，我们需要了解到网络编程种使用到的基础协议。</p><blockquote><p>代码地址：<a href="https://github.com/q792821266/FromNetease/tree/main/chapter-2">https://github.com/q792821266/FromNetease/tree/main/chapter-2</a></p></blockquote><h1 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP&#x2F;UDP协议"></a>TCP&#x2F;UDP协议</h1><h2 id="OSI-网络七层模型"><a href="#OSI-网络七层模型" class="headerlink" title="OSI 网络七层模型"></a>OSI 网络七层模型</h2><p>为使不同计算机厂家的计算机能够互相通信，以便在更大的范围内建立计算机网络，有必要建立一个国际范围的网络体系结构的标准。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635594756086-57f94165-da81-4cd0-bc9a-d6c5e040d2e9.png#averageHue=%23ebe7e2&clientId=u3a4e5b82-6605-4&from=paste&height=515&id=ub1167634&originHeight=515&originWidth=1296&originalType=binary&ratio=1&rotation=0&showTitle=false&size=242306&status=done&style=none&taskId=u6e8fa34f-77c0-4cc5-804d-281e543734d&title=&width=1296" alt="image.png"><br>从底至顶：<br>物理层：使原始的数据比特流能在物理介质上传输。<br>数据链路层：通过校验、确认和反馈重发等手段，形成稳定的数据链路。<br>网络层：进行路由选择和流量控制（IP协议）<br>传输层：提供可靠的端口到端口的数据传输服务（TCP&#x2F;UDP协议）<br>会话层：负责建立、管理和终止进程之间的会话和数据交换<br>表示层：负责数据格式转换、数据加密与解密、压缩与解压缩等<br>应用层：为用户的应用进程提供网络服务</p><p>应表会传网数物<br>我们主要了解一下传输层及应用层的原理，如果有兴趣进一步了解的话，可以找一些计算机网络原理的书籍的查阅一下。</p><h3 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h3><p>传输控制协议TCP是Internet一个重要的传输层协议。TCP提供面向连接、可靠、有序的字节流传输服务。应用程序在使用TCP之前，必须先建立TCP连接。<br>数据报文的样式：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635837937595-9507926b-a462-4abc-96a8-317ca219adf9.png#averageHue=%239b9c9b&clientId=u04d42337-f640-4&from=paste&height=447&id=u13c11ada&originHeight=447&originWidth=1283&originalType=binary&ratio=1&rotation=0&showTitle=false&size=179789&status=done&style=none&taskId=u368e58e9-d826-4ba5-b970-d3f7e2deef9&title=&width=1283" alt="image.png"></p><h4 id="TCP握手机制"><a href="#TCP握手机制" class="headerlink" title="TCP握手机制"></a>TCP握手机制</h4><p>TCP三次握手建立连接的意义不在于打通网络，而是在传输之前检测网络的互通性，目的就是最大程度上面检测网络的互通性。<br>具体步骤：</p><ol><li>客户端发送确认请求给服务端，让服务端准备确认</li><li>服务端收到请求后，会返回针对这次的确认请求的结果响应，回复客户端(ack_sql &#x3D; x+1)，当服务端回复了确认的信息，客户端就认为相互之间能够正常建立请求了。</li><li>客户端开始发送建立连接的请求，但不等于就直接建立连接，要端服两方都确认建立连接才会真正建立。</li><li>服务端响应建立连接的请求</li></ol><p>这个过程就好比打电话的时候双方先喂一下（对应步骤1，2），然后A说：我要开始讲了（步骤3），B回复说：你讲吧 我听着（步骤4）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635838627100-409e6ef3-8cb6-4e07-a707-0e28679ab2ce.png#averageHue=%23fafafa&clientId=u04d42337-f640-4&from=paste&height=808&id=udf5dad18&originHeight=808&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&size=176789&status=done&style=none&taskId=u3f2d8e84-7147-4142-8990-95793520009&title=&width=732" alt="image.png"><br>四次挥手：<br>断开连接也是需要双方确认，不能随便断开。<br>步骤：</p><ol><li>客户端发送断开的请求到服务端</li><li>服务端将客户端对应的请求标识为半关闭状态</li><li>客户端收到了响应之后，开始走自己的逻辑关闭，等待释放，因为有可能有在途中数据没有处理完 或者在等待服务端发送未完成的数据</li><li>等待一段时间之后，服务端会主动发送一条等待确认的消息给客户端，告诉客户端，服务端已经可以关闭连接了</li><li>客户端响应这个连接等于说认同服务端关闭的操作，等服务端接收到确认就会关闭连接</li><li>双方都关闭连接</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635841050728-4caaa8cc-1019-4a8f-a388-673e2f2effb1.png#averageHue=%23f8f8f8&clientId=u04d42337-f640-4&from=paste&height=771&id=uac261ad8&originHeight=771&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&size=176136&status=done&style=none&taskId=ud558d3a9-6ba5-494a-8da2-4ee6c7dbcc6&title=&width=732" alt="image.png"></p><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p>UDP是Internet传输层协议。提供无连接、不可靠、数据尽力传输服务，不保证数据一定能传达到。它的数据包结构也比较简单。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635846365266-90df9f40-42e4-446e-a3fa-3f5c1567da36.png#averageHue=%23eaeaea&clientId=u04d42337-f640-4&from=paste&height=612&id=u80380861&originHeight=612&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112608&status=done&style=none&taskId=u9d148b82-a355-4300-9d6d-0ee1631bf1d&title=&width=897" alt="image.png"><br>作为开发人员，我们在使用UDP来构建应用，关注几点：</p><ol><li>应用进程更容易控制发送什么数据以及何时发送</li><li>无需建立连接</li><li>无连接状态</li><li>首部开销小</li></ol><h3 id="UDP和TCP比较"><a href="#UDP和TCP比较" class="headerlink" title="UDP和TCP比较"></a>UDP和TCP比较</h3><table><thead><tr><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>面向连接</td><td>无连接</td></tr><tr><td>提供可靠保证</td><td>不可靠</td></tr><tr><td>慢</td><td>快</td></tr><tr><td>资源占用多</td><td>资源占用少</td></tr></tbody></table><p>快慢是TCP与UDP相对的。物联网、视频语音通讯这些领域使用UDP就很合理。</p><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><p>是一种Internet中应用最广泛得网络应用编程接口，操作系统帮我们实现与3种底层协议接口：</p><ul><li>数据报类型套接字SOCK_DGRAM（面向UDP接口）</li><li>流式套接字SOCK_STREAM（面向TCP接口）</li><li>原始套接字SOCK_RAM（面向网络层协议接口IP、ICMP等）</li></ul><p>主要socket API 机器调用过程：<br>创建套接字-&gt;端点绑定-&gt;发送数据-&gt;接收数据-&gt;释放套接字<br>Socket API：<br>listen()、 accept() 只用于服务端；<br>connect()只用于客户端；<br>socket() 、bind()、 send()、recv()、sendto()、recvfrom()、close()<br>socket编程了解一下就行了，属于比较底层的东西，在他的基础上JAVA有很良好的网络编程解决方案，目前用得最多的应该式Netty</p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>最开始的时候Java如何去提供一个网络编程的实现？这部分我们直接上代码~：</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>在服务端我们需要创建一个ServerSocket，并且绑定指定的端口:<br><code>ServerSocket serverSocket = new ServerSocket(8080)；</code><br>然后通过accept阻塞地拿去过来的请求：<br><code>Socket request = serverSocket.accept();</code><br>通过Socket对象可以获取客户端的请求，需要加上IO操作，所以JAVA程序中需要net + io 才能实现一个BIO的程序：<br><code>InputStream input = request.getInputStream();</code></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>而在客户端这边需要创建Socket对象，而非ServerSocket对象：<br><code>Socket socket = new Scoket(&quot;localhost&quot;,8080);</code><br>利用IO中的outputStream来发送消息给服务端：<br><code>OutputStream out = socket.getOutputStream();</code><br>使用OutputStream的write方法把消息发送到服务端，write()也是阻塞的：<br><code>String msg = &quot;moumoumou&quot;；</code><br><code>out.write(msg.getBytes(&quot;UTF-8&quot;));</code></p><p>由于服务端是阻塞的，所以我们只能一个一个地处理请求，等于说一对一的服务，对于服务端来说这样的处理方式肯定是不合理的，需要对此进行优化，想到阻塞的实际是阻塞线程，是不是如果我们将收到请求后处理的部分代码写在一个线程中就能满足我们处理多个请求的需求呢？<br>于是乎有了这样的一个版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BIOServer1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br>        System.out.println(<span class="hljs-string">&quot;tomcat 服务器启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (!serverSocket.isClosed()) &#123;<br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> serverSocket.accept();<span class="hljs-comment">//阻塞</span><br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + request.toString());<br>            threadPool.execute(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 接收数据、打印</span><br>                    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> request.getInputStream();<br>                    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                    String msg;<br>                    <span class="hljs-keyword">while</span> ((msg = reader.readLine()) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 阻塞</span><br>                        <span class="hljs-keyword">if</span> (msg.length() == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        System.out.println(msg);<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span>+ request.toString());<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        request.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们accept接受到新的请求的时候，就起了一个新的线程来单独处理这个请求，而不阻塞主线程。为了节省资源，用了线程池。<br>这个服务端已经可以同时处理多个客户端请求了，引入线程池来处理新连接的请求，只是说处理请求的能力取决于线程池的大小，因为线程处理任务也是阻塞的（代码的第16行）：</p><hr><h3 id="加入HTTP支持"><a href="#加入HTTP支持" class="headerlink" title="加入HTTP支持"></a>加入HTTP支持</h3><p>服务端的响应需要展示在不同的终端上，比如最开始了解的TCP\UDP，还有一种常用的，供浏览器使用的是http协议，我们的程序并没有对http的支持，所以下面试着给程序添加http协议，以便可以使用浏览器可以获得服务端的响应。<br>这个是http请求的结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635950370495-3c83a906-ec43-41a0-baf8-a534653ef323.png#averageHue=%23a5a4a2&clientId=ue4b50aa6-39d9-4&from=paste&height=644&id=u21eadb04&originHeight=644&originWidth=1769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=640660&status=done&style=none&taskId=uf41f9d83-9704-4e90-bf2e-9758ba7bdea&title=&width=1769" alt="image.png"><br>http响应的结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635950529316-176241df-b7e2-4165-b1f2-aeeb9d8ea251.png#averageHue=%23a2a2a1&clientId=ue4b50aa6-39d9-4&from=paste&height=661&id=u5e665659&originHeight=661&originWidth=1788&originalType=binary&ratio=1&rotation=0&showTitle=false&size=363480&status=done&style=none&taskId=ucbb222cc-1d07-4dc3-989d-e1c1c35275d&title=&width=1788" alt="image.png"><br>要使我们刚刚的程序支持http，只需要在响应上加上给协议需要的数据结构就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> request.getOutputStream();<br>outputStream.write(<span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());<br>outputStream.write(<span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span>.getBytes());<br>outputStream.write(<span class="hljs-string">&quot;Hello World&quot;</span>.getBytes());<br>outputStream.flush();<br></code></pre></td></tr></table></figure><p>这就是一个极为简单的协议开发与支持的过程。<br>对于这样的服务端程序，其实局限还是很大的，为了能开发出更理想的服务端，我们不得不搞清楚目前的问题出在哪里。</p><hr><p>我们回归BIO，再理解一下之前说的阻塞的定义，以及线程同步异步的定义，以便更好地进行优化：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635951608132-20d6323e-2a46-42aa-943f-23eda29278af.png#averageHue=%23f2f2f2&clientId=ue4b50aa6-39d9-4&from=paste&height=549&id=u5ee319de&originHeight=549&originWidth=1786&originalType=binary&ratio=1&rotation=0&showTitle=false&size=414739&status=done&style=none&taskId=u973ea9f4-3db2-46ad-adb2-d4c9059b6e8&title=&width=1786" alt="image.png"><br>同步与阻塞是两个针对请求与处理的不同的概念。线程的引入解决了同步与异步的问题。阻塞带来的问题就是 处理网络IO的时候，一个线程只能处理一个请求。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1635951702321-bdb19d55-d6b0-49d3-8bb2-81d71b6e98f5.png#averageHue=%23ededed&clientId=ue4b50aa6-39d9-4&from=paste&height=317&id=u2fa71f3a&originHeight=317&originWidth=1791&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190083&status=done&style=none&taskId=ud9d5f127-283d-445a-9014-a17d618d54c&title=&width=1791" alt="image.png"><br>为了解决阻塞这个最大问题，NIO应运而生。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>早在Java 1.4，就已经提供了新的JAVA IO操作非阻塞API，想去替代JAVA IO 和JAVA Networking相关的API。<br>NIO中有三个核心组件ByteBuffer （缓冲区）、 Channel（通道） 、Selector（选择器）</p><h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><p>Buffer本质上是一个可以写入数据的内存块（类似数组），也可以再次读取，内存块被封装在NIO Buffer对象中，该对象提供了一组方法，可以更轻松地使用内存块。明显是针对数组这种不方便的数据结构而产生的一种数据结构。Buffer API相对数组更容易操作和管理。<br>使用Buffer进行读写，需要如下四个步骤：</p><ol><li>将数据写入缓冲区</li><li>调用buffer.flip()，转换位读取模式</li><li>进行数据读取</li><li>调用buffer.clear() 或者 buffer.compact() （清除已读数据）清除缓冲区内数据。</li></ol><h4 id="ByteBuffer-工作原理"><a href="#ByteBuffer-工作原理" class="headerlink" title="ByteBuffer 工作原理"></a>ByteBuffer 工作原理</h4><p>在Buffer中有三个重要的属性：</p><ul><li>capacity 容量：作为一个内存块，Buffer具有一定的大小，且是固定的，即是容量</li><li>postition 位置：写入模式下就是写入数据的起始位置，读取模式下就是读取数据的起始位置</li><li>limit 限制：写入模式下，等于buffer的容量，读取模式下，等于已写入的数据量</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637135130966-8874ce3e-7a65-4111-95e8-77ad84527d1c.png#averageHue=%23fcfbfa&clientId=u049b0928-2628-4&from=paste&height=543&id=uc1054ec5&originHeight=543&originWidth=1421&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178053&status=done&style=none&taskId=u985dcf42-b1cc-40fd-8ad3-8ede8762f3b&title=&width=1421" alt="image.png"><br>这个API的使用就直接写代码去理解了，没必要用过多的文字帮忙理解  , 代码示例：<a href="https://github.com/q792821266/FromNetease/blob/main/chapter-2/src/main/java/com/study/hc/net/nio/BufferDemo.java">BufferDemo.java</a><br>如果你点开ByteBuffer的源码可以发现，实际上我们操作的还是一个byte[]：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1980660/1721894283477-f1ab99ed-92ef-434a-b39c-3ea57ff1cd3b.png#averageHue=%2324283d&clientId=uab3c79a7-b958-4&from=paste&height=176&id=u9dc400bd&originHeight=176&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24848&status=done&style=none&taskId=u0230c013-cba5-496c-a419-604da7f0502&title=&width=598" alt="image.png"><br>但ByteBuffer可不只是做了一层操作上的封装，它还为我们提供了两种内存实现。</p><h4 id="ByteBuffer内存类型"><a href="#ByteBuffer内存类型" class="headerlink" title="ByteBuffer内存类型"></a>ByteBuffer内存类型</h4><p>ByteBuffer默认在堆中为我们申请内存（非直接内存），它还额外为性能关键型的代码提供了直接内存（Direct Memory）的实现。<br>堆外内存通过ByteBuffer.allocateDirect(bytes) 就可以实现申请。<br>堆外内存的<strong>好处</strong>在于：</p><ul><li>进行网络IO 或者文件IO时 比堆内内存少一次拷贝。正常来说我们想要把数据写入到文件或者网络socket是 需要调用操作系统的api， 将jvm heap中的数据先复制一份到堆外内存中（file&#x2F;socket - os memory - jvm heap） 。然而为什么会多这一步，这是因为GC会移动内存地址的原因，在写file或socket的过程中，为防止GC把数据地址改变导致找不到数据的问题，数据会先被移到堆外后，再写入，这个是操作系统帮我们实现的。</li><li>堆外内存在GC的范围之外，降低了GC的压力，并且实现了自动管理：DirectByteBuffer 中有一个Cleaner对象（PhantopmReference），Cleaner被GC前会执行clean()方法，出发DirectByteBuffer中定义的DeAllocator。</li></ul><p>使用堆外内存的建议：</p><ul><li>能显著提高性能的时候才去使用；</li><li>分配给一些大型、寿命长的数据（网络传输、文件读写）</li><li>通过虚拟机参数MaxDirectMemorySize限制大小，防止耗光物理的的内存。</li></ul><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>buffer装载好数据就通过channel传递出去<br>对比之前的BIO ：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1637138676342-bde35f40-614c-4e49-95dd-86de530da802.png#averageHue=%23e7eae8&clientId=u049b0928-2628-4&from=paste&height=495&id=u9e01f023&originHeight=495&originWidth=1672&originalType=binary&ratio=1&rotation=0&showTitle=false&size=391275&status=done&style=none&taskId=u9c7ca5a8-f506-43b7-8e16-d0959d53144&title=&width=1672" alt="image.png"><br>在之前的BIO编程中，通过socket + IOStream来完成，由对应的IO包与NET包协同完成，而NIO中 我们通过Buffer + Channel 来实现，且这两个实现都是由NIO包提供的。 Channel的API涵盖了UDP&#x2F;TCP网络和文件IO ，包括FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel ，<br>Channel 肩负了创建网络连接 以及 处理数据 的工作。<br>和标准的IO Stream操作相比，NIO在同一个Channel中对数据进行读取和写入，而不需要Input Output Stream两个对象，Stream通常都是单向的；可以非阻塞地将数据读取和写入Channel；Channel 始终读取或写入缓冲区。</p><h4 id="ServerChannel"><a href="#ServerChannel" class="headerlink" title="ServerChannel"></a>ServerChannel</h4><p>用于建立TCP网络连接，类似java.net.Socket。<br>有两种创建SocketChannel形式：</p><ol><li><p>客户端主动发起与服务器的连接</p></li><li><p>服务端获取的新连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端主动发起连接方式</span><br><span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open();<br><span class="hljs-comment">//设置为非阻塞模式</span><br>socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>socketChannel.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>));<br><span class="hljs-comment">//向通道写入数据</span><br>channel.write(byteBuffer);<br><span class="hljs-comment">//通道从缓冲区中读取数据，读取响应</span><br><span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> socketChannle.read(byteBuffer);<br><br><span class="hljs-comment">//关闭连接</span><br>scoketChannel.close();<br></code></pre></td></tr></table></figure><p>可以看到我们可以直接操作Channel来进行读写，需要注意的是write()和read()方法都是非阻塞的：</p><ul><li>writer()可能尚未写入任何内容就返回了，所以一般会在循环中调用writer()，</li><li>read()方法则可能没读取到数据直接返回，所以需要根据返回的int值来判断读取的字节数。</li></ul></li></ol><h4 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h4><p>ServerSocketChannel可以监听新建的TCP连接通道，用来替换BIO的ServerSocket。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建网络服务端</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br>serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>)); <span class="hljs-comment">// 绑定端口</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept(); <span class="hljs-comment">// 获取新tcp连接通道</span><br>    <span class="hljs-keyword">if</span>(sockerChannel != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">//处理请求</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与BIO重要的区别在于ServerSocketChannel.accept() ：当配置成非阻塞时，如果没有挂起的连接，该方法会立即返回null，所以我们必须检查返回的SocketChannel是否为null。<br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 创建网络服务端</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        <span class="hljs-comment">// 设置为非阻塞模式</span><br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 绑定端口</span><br>        serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        System.out.println(<span class="hljs-string">&quot;启动成功&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 获取新tcp连接通道</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>            <span class="hljs-comment">// tcp请求 读取/响应</span><br>            <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>                <span class="hljs-comment">// 默认是阻塞的,一定要设置为非阻塞</span><br>                socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                        <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (requestBuffer.position() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                    &#125;<br>                    requestBuffer.flip();<br>                    <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                    requestBuffer.get(content);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                    System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span> + socketChannel.getRemoteAddress());<br><br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                            <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                        <span class="hljs-comment">// 非阻塞</span><br>                        socketChannel.write(buffer);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 用到了非阻塞的API, 在设计上,和BIO可以有很大的不同.继续改进</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>和BIO相比 ，其实只是换了api来实现通信，和BIO的实际使用效果是没有区别的，接收到连接之后还是会阻塞处理，BIO是accept阻塞，这个NIO是while阻塞，后续会继续优化，思考一下怎么来去除阻塞。<br>提供一种思路，将请求存在一个数据结构中，然后逐个处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;SocketChannel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept(); <span class="hljs-comment">// 获取新tcp连接通道</span><br>    <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123;<br>        System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认是阻塞的,一定要设置为非阻塞</span><br>        channels.add(socketChannel);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有新连接的情况下,就去处理现有连接的数据,处理完的就删除掉</span><br>        Iterator&lt;SocketChannel&gt; iterator = channels.iterator();<br>        <span class="hljs-comment">//这里的while 循环并不会阻塞</span><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                <span class="hljs-keyword">if</span> (ch.read(requestBuffer) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 等于0,代表这个通道没有数据需要处理,那就待会再处理</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">//业务代码</span><br><br>                <span class="hljs-comment">//处理完成后移除</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>❓这样我们确实做到了一个线程处理多个连接，并且是非阻塞的。但是这种低效的循环检查，不应当也不会是NIO服务端的正确使用方式。这时候让我们引出NIO中可以让我们避免循环检查这样的伪实现吧。</p><h4 id="Selector选择器"><a href="#Selector选择器" class="headerlink" title="Selector选择器"></a>Selector选择器</h4><p>Selector是一个Java NIO组件，可以检查一个或多个NIO Channel，并确定哪些通道已准备好进行读取或写入。实现单线程可以管理多个通道，从而管理多个网络通道。&#96;&#96;<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1980660/1721911386568-f0b011b8-15ad-4ffe-b1c1-172347132941.png#averageHue=%23fefefc&clientId=uab3c79a7-b958-4&from=paste&height=544&id=u6d39b2dc&originHeight=544&originWidth=627&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46532&status=done&style=none&taskId=u009d9244-673f-4561-9101-42ce4b217ce&title=&width=627" alt="image.png"><br>一个线程使用Selector监听多个channel的不同事件：<br>四个事件分别对应SelectKey四个常量：</p><ol><li>Connect 连接 <code>SelectionKey.OP_CONNECT</code></li><li>Accept 准备就绪 <code>OP_ACCEPT</code></li><li>Read 读取 <code>OP_READ</code></li><li>Write 写入 <code>OP_WRITE</code></li></ol><p>关于Selector如何实现的，下面是一点点源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(AbstractSelectableChannel ch, <span class="hljs-type">int</span> ops, Object att)</span> &#123;<br>    <span class="hljs-comment">// 创建 SelectionKeyImpl 实例，绑定通道和选择器</span><br>    <span class="hljs-type">SelectionKeyImpl</span> <span class="hljs-variable">sk</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKeyImpl</span>((SelChImpl)ch, <span class="hljs-built_in">this</span>);<br>    <br>    <span class="hljs-comment">// 关联附加对象</span><br>    sk.attach(att);<br>    <br>    <span class="hljs-comment">// 同步块，确保线程安全</span><br>    <span class="hljs-keyword">synchronized</span> (publicKeys) &#123;<br>        <span class="hljs-comment">// 将 SelectionKeyImpl 实例注册到内部数据结构中</span><br>        implRegister(sk);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置兴趣操作</span><br>    sk.interestOps(ops);<br>    <br>    <span class="hljs-comment">// 返回 SelectionKeyImpl 实例</span><br>    <span class="hljs-keyword">return</span> sk;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">implRegister</span><span class="hljs-params">(SelectionKeyImpl ski)</span> &#123;<br>    <span class="hljs-comment">// 将通道的文件描述符FDVal 与 SelectionKeyImpl 实例映射</span><br>    fdToKey.put(ski.channel().getFDVal(), ski);<br>    <br>    <span class="hljs-comment">// 将通道的文件描述符和兴趣操作添加到 pollWrapper 中</span><br>    pollWrapper.addFD(ski.channel().getFDVal(), ski.interestOps());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总体看下来 基本也是将通道封装，放入一个数据结构中，并设置好感兴趣的事件，在事件发生时，执行通知。更底层的原理涉及到操作系统的多路复用。</p><p>所以<br>实现一个线程处理多个通道的核心概念理解：事件驱动机制。<br>在非阻塞的网络通道下，开发者通过Selector注册对于通道感兴趣的事件类型，线程通过监听事件来触发相应的代码执行。使用Selector之后我们从循环监听Channel ，变成监听事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 创建网络服务端ServerSocketChannel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 设置为非阻塞模式</span><br><br><span class="hljs-comment">// 2. 构建一个Selector选择器,并且将channel注册上去</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">// 0 代表对什么事件都不感兴趣，这里是为了下面的interestOps使用铺垫</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocketChannel.register(selector, <span class="hljs-number">0</span>, serverSocketChannel);<span class="hljs-comment">// 将serverSocketChannel注册到selector</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT); <span class="hljs-comment">// 对serverSocketChannel上面的accept事件感兴趣(serverSocketChannel只能支持accept操作)</span><br><br><span class="hljs-comment">// 3. 绑定端口</span><br>serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br>System.out.println(<span class="hljs-string">&quot;启动成功&quot;</span>);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 不再轮询通道,改用下面轮询事件的方式.select方法有阻塞效果,直到有事件通知才会有返回</span><br>    selector.select();<br>    <span class="hljs-comment">// 获取事件</span><br>    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>    <span class="hljs-comment">// 遍历查询结果</span><br>    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();<br>    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>        <span class="hljs-comment">// 被封装的查询结果</span><br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>        iter.remove();<br>        <span class="hljs-comment">// 关注 Read 和 Accept两个事件</span><br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> (ServerSocketChannel) key.attachment();<br>            <span class="hljs-comment">// 将拿到的客户端连接通道,注册到selector上面</span><br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSocketChannel</span> <span class="hljs-operator">=</span> server.accept(); <span class="hljs-comment">// mainReactor 轮询accept</span><br>            clientSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>            clientSocketChannel.register(selector, SelectionKey.OP_READ, clientSocketChannel);<br>            System.out.println(<span class="hljs-string">&quot;收到新连接 : &quot;</span> + clientSocketChannel.getRemoteAddress());<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.attachment();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-keyword">while</span> (socketChannel.isOpen() &amp;&amp; socketChannel.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                    <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                requestBuffer.flip();<br>                <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                requestBuffer.get(content);<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                System.out.println(<span class="hljs-string">&quot;收到数据,来自：&quot;</span> + socketChannel.getRemoteAddress());<br>                <span class="hljs-comment">// TODO 业务操作 数据库 接口调用等等</span><br><br>                <span class="hljs-comment">// 响应结果 200</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                    socketChannel.write(buffer);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-comment">// e.printStackTrace();</span><br>                key.cancel(); <span class="hljs-comment">// 取消事件订阅</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    selector.selectNow();<br>&#125;<br><span class="hljs-comment">// 问题: 此处一个selector监听所有事件,一个线程处理所有请求事件. 会成为瓶颈! 要有多线程的运用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>来，试着总结一下：</p><h2 id="NIO-对比-BIO"><a href="#NIO-对比-BIO" class="headerlink" title="NIO 对比 BIO"></a>NIO 对比 BIO</h2><p><img src="https://cdn.nlark.com/yuque/0/2024/png/1980660/1721914151586-c883545c-dffb-4b1e-99bc-3b0f602705e9.png#averageHue=%23f3f2f2&clientId=uab3c79a7-b958-4&from=paste&height=617&id=ud3f5d9b5&originHeight=617&originWidth=1571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=311297&status=done&style=none&taskId=u22e1991e-2210-472c-bb8a-c0285abad3e&title=&width=1571" alt="image.png"></p><p>如果你的程序需要支撑大量的连接，使用NIO是最好的方式。在Tomcat8之后，已经去除了BIO相关的网络处理代码，默认采用NIO来进行网络处理。</p><hr><p>那是不是说我们NIOServerV2版本已经完美了呢？你可能已经留意到最后的注释了。<br><code>//问题: 此处一个selector监听所有事件,一个线程处理所有请求事件. 会成为瓶颈! 要有多线程的运用</code>  一个线程处理所以事件不是说不好，确实很节省资源，但是我没的计算资源不会那么紧张，我们需要利用现在多核计算机的优势，合理平衡资源的使用。<br>没错 ，这个方案就是 NIO + 多线程。<br>在Doug Lea（看过源码你肯定对这位很熟悉）的文章《<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a>》 提出：<br><img src="https://cdn.nlark.com/yuque/0/2024/png/1980660/1721914711847-2b800e50-6970-4205-82ea-1e50d24f4360.png#averageHue=%23f4f1e6&clientId=uab3c79a7-b958-4&from=paste&height=625&id=udfaea7b9&originHeight=625&originWidth=1696&originalType=binary&ratio=1&rotation=0&showTitle=false&size=560239&status=done&style=none&taskId=uf15e43b8-1532-4521-9fa7-c47800fc30d&title=&width=1696" alt="image.png"><br>这里会分为两种，一种是单个Reactor模式（左），另一种就是多个Reactor（右）。<br>所谓单个Reactor模式，就是由两种线程，一种是 Reactor线程，用来处理网络相关操作，包括客户端连接、连接数据的接收。接收到数据之后，需要做什么操作，可能是协议解析，业务处理，由单独的线程池来处理。这样将网络操作和耗时的数据处理程序分开，可以提升资源利用效率。<br>对应地，多Reactor模式就是将单模式中的Reactor细分成两个部分，处理网络连接的由一个Reactor（mainReactor）来做， 处理数据读写的由另一个Reactor（subReactor）。<br>本质上，Reactor是在底层网络事件处理和数据处理中间多了一层分发。<br>现在我们带着这种思想来看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * NIO selector 多路复用reactor线程模型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServerV3</span> &#123;<br>    <span class="hljs-comment">/** 处理业务操作的线程 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">workPool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 封装了selector.select()等事件轮询的代码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReactorThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>        Selector selector;<br>        LinkedBlockingQueue&lt;Runnable&gt; taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Selector监听到有事件后,调用这个方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">ReactorThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            selector = Selector.open();<br>        &#125;<br><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 轮询Selector事件</span><br>            <span class="hljs-keyword">while</span> (running) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 执行队列中的任务</span><br>                    Runnable task;<br>                    <span class="hljs-keyword">while</span> ((task = taskQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>                        task.run();<br>                    &#125;<br>                    selector.select(<span class="hljs-number">1000</span>);<br><br>                    <span class="hljs-comment">// 获取查询结果</span><br>                    Set&lt;SelectionKey&gt; selected = selector.selectedKeys();<br>                    <span class="hljs-comment">// 遍历查询结果</span><br>                    Iterator&lt;SelectionKey&gt; iter = selected.iterator();<br>                    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>                        <span class="hljs-comment">// 被封装的查询结果</span><br>                        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>                        iter.remove();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">readyOps</span> <span class="hljs-operator">=</span> key.readyOps();<br>                        <span class="hljs-comment">// 关注 Read 和 Accept两个事件</span><br>                        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">try</span> &#123;<br>                                <span class="hljs-type">SelectableChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SelectableChannel) key.attachment();<br>                                channel.configureBlocking(<span class="hljs-literal">false</span>);<br>                                handler(channel);<br>                                <span class="hljs-keyword">if</span> (!channel.isOpen()) &#123;<br>                                    key.cancel(); <span class="hljs-comment">// 如果关闭了,就取消这个KEY的订阅</span><br>                                &#125;<br>                            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                                key.cancel(); <span class="hljs-comment">// 如果有异常,就取消这个KEY的订阅</span><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                    selector.selectNow();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> SelectionKey <span class="hljs-title function_">register</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-comment">// 为什么register要以任务提交的形式，让reactor线程去处理？</span><br>            <span class="hljs-comment">// 因为线程在执行channel注册到selector的过程中，会和调用selector.select()方法的线程争用同一把锁</span><br>            <span class="hljs-comment">// 而select()方法是在eventLoop中通过while循环调用的，争抢的可能性很高，为了让register能更快的执行，就放到同一个线程来处理</span><br>            FutureTask&lt;SelectionKey&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; channel.register(selector, <span class="hljs-number">0</span>, channel));<br>            taskQueue.add(futureTask);<br>            <span class="hljs-keyword">return</span> futureTask.get();<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStart</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!running) &#123;<br>                running = <span class="hljs-literal">true</span>;<br>                start();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ServerSocketChannel serverSocketChannel;<br>    <span class="hljs-comment">// 1、创建多个线程 - accept处理reactor线程 (accept线程)</span><br>    <span class="hljs-keyword">private</span> ReactorThread[] mainReactorThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 2、创建多个线程 - io处理reactor线程  (I/O线程)</span><br>    <span class="hljs-keyword">private</span> ReactorThread[] subReactorThreads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>[<span class="hljs-number">8</span>];<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化线程组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newGroup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建IO线程,负责处理客户端连接以后socketChannel的IO读写</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subReactorThreads.length; i++) &#123;<br>            subReactorThreads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                    <span class="hljs-comment">// work线程只负责处理IO处理，不处理accept事件</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (SocketChannel) channel;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">requestBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    <span class="hljs-keyword">while</span> (ch.isOpen() &amp;&amp; ch.read(requestBuffer) != -<span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-comment">// 长连接情况下,需要手动判断数据有没有读取结束 (此处做一个简单的判断: 超过0字节就认为请求结束了)</span><br>                        <span class="hljs-keyword">if</span> (requestBuffer.position() &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (requestBuffer.position() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果没数据了, 则不继续后面的处理</span><br>                    requestBuffer.flip();<br>                    <span class="hljs-type">byte</span>[] content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[requestBuffer.limit()];<br>                    requestBuffer.get(content);<br>                    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(content));<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收到数据,来自：&quot;</span> + ch.getRemoteAddress());<br><br>                    <span class="hljs-comment">// TODO 业务操作 数据库、接口...</span><br>                    workPool.submit(() -&gt; &#123;<br>                    &#125;);<br><br>                    <span class="hljs-comment">// 响应结果 200</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HTTP/1.1 200 OK\r\n&quot;</span> +<br>                    <span class="hljs-string">&quot;Content-Length: 11\r\n\r\n&quot;</span> +<br>                    <span class="hljs-string">&quot;Hello World&quot;</span>;<br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(response.getBytes());<br>                    <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>                        ch.write(buffer);<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-comment">// 创建mainReactor线程, 只负责处理serverSocketChannel</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mainReactorThreads.length; i++) &#123;<br>            mainReactorThreads[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorThread</span>() &#123;<br>                <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">incr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(SelectableChannel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    <span class="hljs-comment">// 只做请求分发，不做具体的数据读取</span><br>                    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> (ServerSocketChannel) channel;<br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> ch.accept();<br>                    socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                    <span class="hljs-comment">// 收到连接建立的通知之后，分发给I/O线程继续去读取数据</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> incr.getAndIncrement() % subReactorThreads.length;<br>                    <span class="hljs-type">ReactorThread</span> <span class="hljs-variable">workEventLoop</span> <span class="hljs-operator">=</span> subReactorThreads[index];<br>                    workEventLoop.doStart();<br>                    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> workEventLoop.register(socketChannel);<br>                    selectionKey.interestOps(SelectionKey.OP_READ);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;收到新连接 : &quot;</span> + socketChannel.getRemoteAddress());<br>                &#125;<br>            &#125;;<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化channel,并且绑定一个eventLoop线程</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1、 创建ServerSocketChannel</span><br>        serverSocketChannel = ServerSocketChannel.open();<br>        serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 2、 将serverSocketChannel注册到selector</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(mainReactorThreads.length);<br>        mainReactorThreads[index].doStart();<br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> mainReactorThreads[index].register(serverSocketChannel);<br>        selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定端口</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException IO异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//  1、 正式绑定端口，对外服务</span><br>        serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>        System.out.println(<span class="hljs-string">&quot;启动完成，端口8080&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">NIOServerV3</span> <span class="hljs-variable">nioServerV3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NIOServerV3</span>();<br>        nioServerV3.newGroup(); <span class="hljs-comment">// 1、 创建main和sub两组线程</span><br>        nioServerV3.initAndRegister(); <span class="hljs-comment">// 2、 创建serverSocketChannel，注册到mainReactor线程上的selector上</span><br>        nioServerV3.bind(); <span class="hljs-comment">// 3、 为serverSocketChannel绑定端口</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯 多看几次吧。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>网络编程本身的复杂性，以及JDK API的使用难度高，所以在开源社区中有很多对JDK NIO封装、增强后的网络编程框架，例如：Netty 、Mina等。</p>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zookeeper</title>
    <link href="/2024/06/18/zookeeper/"/>
    <url>/2024/06/18/zookeeper/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>ZooKeeper（后文简称ZK）是一种用于分布式应用程序的性能协调服务，提供一种集中式的信息存储服务<br>特点：数据存储在内存中，类似文件系统的树型结构（文件和目录），高吞吐和低延迟，集群高可靠<br>作用：基于ZooKeeper可以实现分布式统一配置中心，服务注册中心，分布式锁等功能<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645672636332-65e246bd-4b9a-4f2e-a01b-1155b03d9fb6.png#averageHue=%23f9f5f2&clientId=u9a40121b-87d1-4&from=paste&height=466&id=u71b5976b&originHeight=466&originWidth=1785&originalType=binary&ratio=1&rotation=0&showTitle=false&size=240509&status=done&style=none&taskId=u9f6fc748-f8af-4a54-bcca-7b6134ec2d2&title=&width=1785" alt="image.png"></p><p>单机系统的处理能力有限，且可用性和可靠性都比较低，所以需要分布式系统，特别在大型的互联网公司对数据可靠的要求非常高。于是将原本单体系统会被拆分成非常多的细微的小的系统，可能在单体上的一个服务会被分配到多个服务，多个计算节点协同一起完成。这个过程会出现什么问题？这种拆分服务去协同工作是有顺序要求的，就需要有一种机制来协调节点来按照我们想要的顺序要完成分配的计算任务。还有一点，在单系统中会出现资源竞争，会碰到多线程竞争产生的线程安全问题，所以在原来的单个系统会采用锁的机制来保证程序的正确性。而这种情况也会出现在分布式系统里面发生，且这个线程可能就已经不是单个进程中的多线程问题了，而是不同节点中多个进程的多线程问题了，于是引入了分布式锁来处理这类问题。<br>服务调用顺序的协调，资源竞争的协调都是分布式协调服务的作用。当把协调服务中公共基础部分抽取出来做成一个独立的公共的基础服务供大家使用，这就是分布式协调服务。免去了在多个分布式系统里面重复的工作。ZooKeeper就是这样的一种分布式协调服务的提供者。在基于分布式协调服务之上，我们可以实现具体的功能：注册中心、分布式锁。<br>ZooKeeper是雅虎在分布式实践过程中产生的产品<br>应用案例：<br>Hbase 使用ZK进行Master选举，服务间协调<br>Solr使用ZK进行集群管理、Leader选举、配置管理<br>dubbo使用ZK来完成服务注册和发现<br>Mycat 使用ZK来集群管理、配置管理<br>Sharding-sphere 使用ZK来集群管理、配置管理<br>ZK同类产品：<br>consul 国外较多，用途和ZK类似<br>etcd 轻量级的<br>Doozer 高可用 完整一致性，小量且非常重要的数据场景</p><p>ZK官网：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><p>ZK搭建可以参考官网的指导，也可以通参考文档《Zookeeper安装手册》</p><p>CLI-操作命令<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645675190606-a8635103-c095-4663-ad87-a75d3d81e007.png#averageHue=%23e7e7e7&clientId=u9a40121b-87d1-4&from=paste&height=793&id=ubb4af44e&originHeight=793&originWidth=1459&originalType=binary&ratio=1&rotation=0&showTitle=false&size=176686&status=done&style=none&taskId=ufca8e719-2c3e-4649-8b9d-3cf5a6f4571&title=&width=1459" alt="image.png">setquota，设置配额，表示节点下可以有多少个子节点，但是并不是强制的，原本指定3，但是你还是创建第4个，但是会记录一条异常日志，表示超长。</p><p>API操作<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645688379168-79925492-d1b6-4c0b-bbf6-7f51d12184ca.png#averageHue=%23e8e8e8&clientId=u9a40121b-87d1-4&from=paste&height=844&id=u5bb5595d&originHeight=844&originWidth=1425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=213256&status=done&style=none&taskId=ubdc0c9c9-2209-4d13-be72-0edd4654951&title=&width=1425" alt="image.png"><br>第三方客户端<br>zkClient<br>Curator</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>zk的核心概念分三块 session、数据模型、watch</p><h2 id="Session会话"><a href="#Session会话" class="headerlink" title="Session会话"></a>Session会话</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645689277144-64fe0c58-0e1f-4a03-bec9-1a4641a7a388.png#averageHue=%23f9f4ee&clientId=ubf509c67-8447-4&from=paste&height=442&id=u97ccd3c0&originHeight=442&originWidth=1239&originalType=binary&ratio=1&rotation=0&showTitle=false&size=186131&status=done&style=none&taskId=u041d4b15-d4e4-4fef-bd57-b40992efabd&title=&width=1239" alt="image.png"><br>客户端要连接到服务端，成功连接就会产生一个会话。会话在zk中属于比较重要的概念。</p><ol><li>一个客户端连接一个会话，由zk分配唯一会话ID</li><li>客户端以特定的时间间隔(tickTime)发送心跳以保持会话有效</li><li>超过会话超时时间未收到客户端的心跳，则判定客户端死了，这个会话超时时间默认为两倍的tickTIme，通过maxSessionTimeout 与minSessionTimeout可以配置这个超时值</li><li>会话中请求按FIFO的顺序执行</li></ol><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>zk提供了集中式的数据存储，存储形式是类似与unix的文件系统，名称空间树的形式</p><ul><li>类似unix文件类型 ，以&#x2F; 为根</li><li>区别unix：节点可以包含与之关联的数据以及子节点（既是文件也是文件夹）</li><li>节点的路径总是标识为规范的、绝对的、斜杠分隔的路径</li></ul><p>一般来讲我们把zk上的数据节点称为znode<br>对于znode有如下性质：</p><ul><li>名称：名称唯一，命名规范</li><li>类型：节点有几种类型：持久、顺序、临时、临时顺序</li><li>数据：节点有它的数据构成</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645689956385-5d2490de-5797-4428-9999-82120e9af040.png#averageHue=%23f7f7f7&clientId=ubf509c67-8447-4&from=paste&height=427&id=u3bfd1dfa&originHeight=427&originWidth=877&originalType=binary&ratio=1&rotation=0&showTitle=false&size=81208&status=done&style=none&taskId=u7e203c1b-d1dd-4263-b0c1-d800c5211fe&title=&width=877" alt="image.png"></p><h3 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h3><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>节点名称有如下限制，除了下述限制外能使用其余任意的unicode字符</p><ul><li>null（\u0000）不能作为路径名的一部分</li><li>\u0001-\u0019 和\u007F-\u009F 不能使用，因为它们不能很好的显示，会以奇怪的方式显示</li><li>\ud800-uf8fff（感觉这里有点问题），\uFFF0-\uFFFF</li><li>“.”字符可以用作另一个名称的一部分，但是”.”和”..”不能当都用于指示路径上的节点，因为zk不能使用相对路径<br>“&#x2F;a&#x2F;b&#x2F;.&#x2F;c” 或“c&#x2F;a&#x2F;b&#x2F;..&#x2F;”为无效内容。</li><li>“zookeeper”为保留节点名</li></ul><h4 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h4><ul><li>持久节点 <code>create /app1 666</code> app1为节点名称，666为数据。没有名称或者数据都是创建不了节点的。</li><li>临时节点 <code>create -e /app2 888</code></li><li>顺序节点 <code>create -s /app1/cp 888</code> </li><li>临时顺序节点 <code>create -e -s /app1/ 888</code></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645700625932-346b814e-3980-4278-879b-5980282debdd.png#averageHue=%230c0906&clientId=ua5136b71-28ae-4&from=paste&height=49&id=u50d51ef1&originHeight=49&originWidth=532&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4876&status=done&style=none&taskId=u4d72d2a8-c80b-4179-908f-74d2424fdbf&title=&width=532" alt="image.png"><br>可以看到真正创建出来的节点是以app1为前缀后面补了10位序列号。<br>        <code>create -s /app1/ aa</code>   0000000001<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645700741711-1352f651-d398-43d7-a2db-5276b5fdf8b2.png#averageHue=%230b0805&clientId=ua5136b71-28ae-4&from=paste&height=45&id=u1cbb03cc&originHeight=45&originWidth=570&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4665&status=done&style=none&taskId=ud71dd0da-6142-4b3f-96ba-aed15b2eb2b&title=&width=570" alt="image.png"><br>这个没有指定节点名，就会直接以序列为名的节点。</p><ol><li>序号为10位十进制序号</li><li>每个父节点一个计数器 </li><li>计数器是带符号int（4字节）到2147483647之后将溢出（导致名称变为“<path-2147483647>”）</li></ol><p>临时节点会在会话结束时被删除。</p><h4 id="数据构成"><a href="#数据构成" class="headerlink" title="数据构成"></a>数据构成</h4><p><strong>节点数据</strong>：存储的协调数据（状态信息、配置、位置信息等）</p><p><strong>数据量上限</strong>：1M  存储数据只是为了完成协调服务，不需要存储很大的量。<br><strong>节点元数据</strong>（stat结构） ： 当我们执行get之后会得到大串的返回<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645708427465-3b0e5472-1b7b-4f27-9dde-66f64de72f4f.png#averageHue=%23070503&clientId=ua5136b71-28ae-4&from=paste&height=284&id=u5114b182&originHeight=284&originWidth=585&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19695&status=done&style=none&taskId=u5573a9a7-28f4-40d2-8f7b-f37c55151a5&title=&width=585" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645708448420-3023364f-0ade-4f20-8f3b-2c65b4911c05.png#averageHue=%23dcdbdb&clientId=ua5136b71-28ae-4&from=paste&height=804&id=u8bda75ff&originHeight=804&originWidth=1188&originalType=binary&ratio=1&rotation=0&showTitle=false&size=218304&status=done&style=none&taskId=u8108bdd8-7594-473e-b7ae-4ad96837401&title=&width=1188" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645751357710-48419291-79a7-4f92-b627-e9902cc4a47b.png#averageHue=%23100a09&clientId=u8cf64b7c-fe99-4&from=paste&height=741&id=uf63f573a&originHeight=741&originWidth=1124&originalType=binary&ratio=1&rotation=0&showTitle=false&size=122381&status=done&style=none&taskId=u5fbab828-0b7d-48cc-a4b4-3796ef4d574&title=&width=1124" alt="image.png"><br>另外，值得一提的是create命令在创建节点时能指定path 和data， 还可以指定 <a href="https://zookeeper.apache.org/doc/r3.7.0/zookeeperProgrammers.html#sc_ZooKeeperAccessControl">ACL</a> (access control )访问控制，形式为scheme:expression,perms  -&gt; ip:19.22.0.0&#x2F;16,read 这就表示ip在19.22.0.0-16有读的权限，具体在使用时可以参考官网。<br>这个功能虽然用的少但是要知晓。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645751960297-9586d6e9-e952-4366-88d1-678229063d19.png#averageHue=%23f6f3ef&clientId=u8cf64b7c-fe99-4&from=paste&height=220&id=ud0fa667d&originHeight=220&originWidth=806&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31987&status=done&style=none&taskId=u00e7f6a8-65eb-46d0-9f63-3fcf44169ce&title=&width=806" alt="image.png"></p><p>对于分布式协调服务，顺序是一个十分重要的概念，所以能够控制顺序的时间就举足轻重。<br>zookeeper中有多种方式来跟踪时间<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645752516232-cc9682e2-5b3c-498d-aa9f-08a6a0bbce27.png#averageHue=%23cdcdcd&clientId=u8cf64b7c-fe99-4&from=paste&height=708&id=u74ae7c8c&originHeight=708&originWidth=1706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=353695&status=done&style=none&taskId=uf6516a62-ccb9-4761-81c7-6b231955372&title=&width=1706" alt="image.png"></p><h2 id="watch监听机制"><a href="#watch监听机制" class="headerlink" title="watch监听机制"></a>watch监听机制</h2><p>非常重要。<br>客户端可以在znodes上设置watch，监听znode的变化。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645752893516-5a35d7d4-6701-4436-9ce3-02576f3b1e78.png#averageHue=%23f6f6f6&clientId=u8cf64b7c-fe99-4&from=paste&height=698&id=ud0e4dbc0&originHeight=698&originWidth=804&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102732&status=done&style=none&taskId=u58effa35-feb2-417d-8b74-86ee7ac83f6&title=&width=804" alt="image.png"><br>通过监听节点，我们可以知道节点是否存在，是否被删除，节点数据变化，节点下子节点的变化等消息。watch是个boolean类型入参。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645753285888-7e15de8b-fe56-421d-8206-a4b24f7d2976.png#averageHue=%23060402&clientId=u8cf64b7c-fe99-4&from=paste&height=457&id=u699191b7&originHeight=457&originWidth=533&originalType=binary&ratio=1&rotation=0&showTitle=false&size=30388&status=done&style=none&taskId=u3028a343-37a7-4157-a23c-852ac692d70&title=&width=533" alt="image.png"><br>比如当我们执行命令<code>get /study 1</code>时会在这个节点上部建一个watch<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645753702742-a6db25b0-c8fc-4312-9ff5-fce1b8171a9f.png#averageHue=%23070503&clientId=u8cf64b7c-fe99-4&from=paste&height=272&id=u52ca187a&originHeight=272&originWidth=493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18444&status=done&style=none&taskId=u736bd684-eff2-4db6-88ef-8750c3cdc64&title=&width=493" alt="image.png"><br>我们再开第二个客户端连接上zk，去修改这个节点时候：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645753790169-2511f096-fd98-4efe-913a-94c133d2e023.png#averageHue=%230f0e0c&clientId=u8cf64b7c-fe99-4&from=paste&height=282&id=u5c90fa4d&originHeight=282&originWidth=588&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20407&status=done&style=none&taskId=u9f898573-d1e0-4326-8ed4-381427d13d0&title=&width=588" alt="image.png"><br>原来的客户端会收到消息<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645753816889-35cb96db-c67f-436d-b081-94133aaebda8.png#averageHue=%23070504&clientId=u8cf64b7c-fe99-4&from=paste&height=353&id=ucd1e3f55&originHeight=353&originWidth=626&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24726&status=done&style=none&taskId=u5cf6be9d-566f-40fb-9c9a-6772c7d5340&title=&width=626" alt="image.png"><br>但是如果你再进行一次修改之后，并不会再触发这个消息。</p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>watch有两种:</p><ul><li>data watch 监听数据变化</li><li>child watch 监听子节点变化</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>watch事件有四种:</p><ul><li>Created event : Enabled with a call to exites</li><li>Deleted event ：Enabled with a call to exists , getData , getChildren</li><li>Changed event: Enabled with a call to exists and getData</li><li>Child event : Enabled with a call to getChildren</li></ul><p>可以看到getData()，getChildren()， exists() 三种方法都会触发事件。</p><h3 id="重要特性"><a href="#重要特性" class="headerlink" title="重要特性"></a>重要特性</h3><p>一次性触发：watch触发之后就会被删除，要持续监控变化，就需要持续设置watch<br>有序性：客户端先得到watch通知，之后才会看到变化结果。<br>更详细地说:</p><ol><li>顺序一致性（Sequential Consistency） ：保证客户端操作是按顺序生效的</li><li>原子性（Atomicity）：更新成功或失败，没有部分成功或失败的情况</li><li>单个系统镜像：无论连接到哪个服务端，客服端看到的结果都是相同的内容</li><li>可靠性：数据的变更不会丢失，除非是被客户端覆盖。每个变更在zk中都是有日志记录的，当有请求进服务端来操作数据时会先写日志，再进行实际的数据操作。如果是集群部署的zk还要发起对应的集群流程。</li><li>及时性：保证系统的客户端当时读取到的数据是最新的。集群内也会及时同步。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用watch的时候要注意以下几点：</p><ul><li>watch是一次性触发器，如果你获得了一个watch时间，并且希望得到关于未来变更的通知，则必须设置另一个watch</li><li>因为watch是一次性触发器，并且在获取时间和发送watch的新请求之间存在延迟，所以不可能可靠地得到节点发生的每个改变，如果对变化有非常强的要求，需要注意这一点。</li><li>一个watch对象只会被特定的通知触发一次。如果一个watch对象同时注册了exits、getData，当节点被删除时，删除事件对exits、getData都有效，但是会调用一次watch通知。</li></ul><p>后续自行写个小demo体验zookeeper的api使用。</p><h1 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h1><p>zk用途广泛，能用于</p><ul><li>数据发布订阅（配置中心）：解决配置问题</li><li>命名服务：标识集群里面的某个服务，当它还没有准备好的时候，我们可以不受干扰的开发其他需要调用这个服务的代码或者部署</li><li>Master选举</li><li>集群管理：实时地动态对集群中节点的加入与退出</li><li>分布式队列</li><li>分布式锁</li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p>正常来说，不比单体应用，分布式系统中配置众多，各个系统之间的关系繁多，每个系统里面或多或少都有些配置信息，并且很可能在都有部分相同的配置项，分布式应用服务众多，于是如何解决系统参数配置及动态改参就成了一个问题。<br>配置中心帮我们解决这个问题，在服务启动时需要用到某个配置时，就去配置中心里面去取。当配置中心的配置发生改动，所有用到该配置的服务都能及时感知到。这个就是配置中心为我们做的事情，统一管理，并且动态配置。<br>如何用zk实现配置中心？经过上面zk的学习我们知道zk的节点可以存储数据，并且节点发生变动就watch机制可以通知到关心数据变化的节点，利用这两点就能实现。<br>我们可以一个<strong>配置项</strong>一个znode，也可以一个<strong>配置文件</strong>一个znode。就比如我们可以把mycat的scheme.xml文件直接存放在zk上当作一个节点，在mycat启动时去zk上获取节点就能获得这个文件。就算再多的mycat实例启动起来，我们也只需要维护这一份scheme.xml就可以了。如果是不同的服务但是有相同的配置项，那就可以采取第一种，将某个配置项作为节点存储到zk。</p><p>参见ConfigCenterDemo.java</p><h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>在系统开发的过程间，不同系统由不同开发小组完成，A服务已经开发完成，但是B服务并没有完成开发。但是A服务的开发者会去负责别的项目的开发，如果等到B服务开发完成再来联调修改什么的操作，对A来说会比较麻烦。能不能达到一个效果就是只要B服务一旦部署上线，A服务中用到B服务的功能就能正常运转，不再需要开发者回过头来再关注A的部署。这时候用到的手段就叫命名服务。B服务只需要给自己的服务命一个名称，然后A服务知道了这个服务名，就可以到命名服务里面去取到它的服务提供详情。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645815722259-3f0ec48c-138c-4f91-ac18-7efbbdb10c17.png#averageHue=%23fefefe&clientId=u25a8184d-a926-4&from=paste&height=385&id=u291f3e06&originHeight=770&originWidth=1231&originalType=binary&ratio=1&rotation=0&showTitle=false&size=225009&status=done&style=none&taskId=ue13ee0c8-7fa0-483a-a299-3eebb7a1b90&title=&width=615.5" alt="image.png"><br>如何解决服务A可以动态得到服务B的调用地址呢？<br>首先A服务去zk上注册一个service B的节点的watch，当B服务准备好的时候将自己注册上zk，就是创建对应的service B节点。</p><h2 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h2><p>在分布式系统中，主从集群是常用的结构，一主多从，主节点负责协调管理集群，主节点一般只有一个，当主节点故障之后，集群还需要保证可用，那么就必须重新选举主节点。这种选举的实现的方式由很多，zk只是其中一种。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645815925808-5a4cb59f-8d50-4a54-89fb-cc0778aee1f1.png#averageHue=%23fdfdfc&clientId=u25a8184d-a926-4&from=paste&height=357&id=ubbd1f534&originHeight=713&originWidth=1299&originalType=binary&ratio=1&rotation=0&showTitle=false&size=237226&status=done&style=none&taskId=u9fca9864-84ca-4224-853f-d4d0b6d6c30&title=&width=649.5" alt="image.png"><br>zk如何帮助我们实现选举？<br>所有从节点都去zk上创建个名称相同的节点，谁成功了，谁就成为了新的主节点，假如实例一创建节点成功，成为了主节点，其他的实例创建就会收到节点已存在的返回，这时候其他节点就只要获取主节点信息就可以了。 主节点必须是个临时节点，因为当实例1宕机的时候，节点就会自动被删除，其他节点才有机会创建新的master节点。<br>除上述过程之外，我们还可以把集群中所有可用的节点都注册称为servers节点，通过这个节点我们就能了解到集群的情况。当实例1称为了主节点之后，它可能需要获取到集群的所有信息，来做管理，这时候servers节点就起到了作用。所有的节点都会在servers下面注册个临时&#x2F;临时顺序节点，这样就方便主节点进行集群管理。具体根据业务需要来实现。如果是顺序节点的存放方式，我们还可以用最小节点的方式来实现选举，即谁的序号最小谁就去当主节点，这样就不需要争抢。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645815998311-09606917-278d-4b26-a561-eccdf4fb4d6d.png#averageHue=%23f6f6f5&clientId=u25a8184d-a926-4&from=paste&height=345&id=u3b6c7659&originHeight=689&originWidth=1404&originalType=binary&ratio=1&rotation=0&showTitle=false&size=297390&status=done&style=none&taskId=ubfd6ca42-5186-4491-b5a4-2c8cf2b0cb8&title=&width=702" alt="image.png"><br>注意，节点宕机就会会话中断，中断时间默认为2倍TikTime，所有消息的通知也会有这么长时间的延迟。</p><p>代码实现见MasterElectionDemo.java</p><h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><p>原理是利用了顺序节点的性质。入队的过程就是创建顺序节点，顺序就是入队顺序，生产者将数据创建为顺序节点放入zk即可。出队，消费者取所有的子节点，移除最小号节点。<br>有个重要的问题，如果是一个无界的队列，那么没有什么问题，一直入队就可以了。如果是要实现一个有界队列，那么就需要生产者在放的时候判断节点下子节点的个数。这时候入队就没有那么随意了，需要用到分布式锁来判断是否超了队列的大小，每个生产者都要抢到锁之后才能取放入。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645817073769-83853268-78e0-4619-bcb5-126bc99c0670.png#averageHue=%23fefefe&clientId=u25a8184d-a926-4&from=paste&height=366&id=u73b23b55&originHeight=731&originWidth=1424&originalType=binary&ratio=1&rotation=0&showTitle=false&size=228536&status=done&style=none&taskId=u34fa3301-bd5d-4451-9b61-b77ded580ed&title=&width=712" alt="image.png"><br>这个留给你去试下，入队的put操作，出队的get操作。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>zk中实现锁的方式有两种：</p><ol><li>创建同名的临时节点</li></ol><p>失败的实例创建watch监听，获得锁的人执行完代码后就要把节点删除，需要抢锁的人就会被通知到去抢。为什么不创建持久节点呢？就是怕抢到锁的实例出现故障宕机，于是就成了死锁问题。<br>这种实现的缺点就是由于只有一个会抢锁成功，所以失败的实例阻塞之后等到再抢锁的时候，会触发成百上千的通知，把所有需要抢锁的实例都“惊醒”。并发量太大就不要采用这种方式。<br>再者如果不是先可重入的锁，那么就会出现如果线程获得锁之后进入下一段代码有需要获取这个锁，就一定拿不到这个锁，等于拿着锁去找锁，死锁了。使用可重入锁同时也要注意解锁条件，必须全部释放才算是完全解锁。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645817747769-e7e47989-9e0d-4d9f-af38-df7e2d9f8610.png#averageHue=%23f69085&clientId=u25a8184d-a926-4&from=paste&height=492&id=u09a5fda1&originHeight=984&originWidth=1998&originalType=binary&ratio=1&rotation=0&showTitle=false&size=473392&status=done&style=none&taskId=u65edb995-95e9-40aa-94ce-7b695378a79&title=&width=999" alt="image.png"><br>代码见ZkDistributeLock.java</p><ol start="2"><li>创建临时顺序节点</li></ol><p>类似银行办公区号等叫号。<br>取号了之后，等唤醒，交由节点序号比自己小的节点来唤醒。2号等1号通知，3号等2号通知…watch只需要注册在需要比自己小的那一个上面就可以了。 锁由最小号的序号获得。这样挨个唤醒的方式解决了第一种的惊群效应。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645818448424-a167d807-a0a3-4429-a9e1-49b05a1cabf3.png#averageHue=%23fef9f6&clientId=u25a8184d-a926-4&from=paste&height=507&id=u8e305e50&originHeight=1014&originWidth=1955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=575940&status=done&style=none&taskId=ucbcac81b-e779-48f1-89a9-c781dd07a5d&title=&width=977.5" alt="image.png"><br>代码见ZkDistributeImproveLock.java</p><h1 id="ZooKeeper集群"><a href="#ZooKeeper集群" class="headerlink" title="ZooKeeper集群"></a>ZooKeeper集群</h1><p>仅仅使用一个zk，可靠性肯定是不高的，zk集群能够提供更高的zk服务。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645844257100-a77f300b-0eaf-4e06-8502-7caa58309764.png#averageHue=%23faf5f0&clientId=u41e4239b-724c-4&from=paste&height=477&id=u5853250b&originHeight=477&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194245&status=done&style=none&taskId=u532081f4-244a-4fda-a48c-c039968f0e7&title=&width=1226" alt="image.png"></p><ul><li>可靠的ZooKeeper服务</li><li>只要集群中的大多数（过半的机器）都准备好，服务就可用</li><li>容错集群设置至少需要三个服务器，强烈建议使用奇数个服务器</li><li>建议每个服务运行在单独的机器上</li><li>其余节点都需要连接到Leader节点接受管理</li></ul><h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>集群的搭建本来是很简单的。<br>只需要增加server.1及之后的配置来告诉集群节点信息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645972850541-604678ab-2417-47bc-a4c7-2b05b35c3ca9.png#averageHue=%23757370&clientId=u0f708a63-ac69-4&from=paste&height=615&id=u7ae5b7d7&originHeight=615&originWidth=624&originalType=binary&ratio=1&rotation=0&showTitle=false&size=175104&status=done&style=none&taskId=ubfb27000-9a65-4412-9296-8ed192ad8ce&title=&width=624" alt="image.png"><br>配置说明</p><ul><li>initLimit<br>集群中的follower服务器（F）与Leader 服务器（L） 之间完成初始化同步连接时能容忍的最多心跳数（TickTime的数量）。如果zk集群环境数量确实很大，同步数据的事件会变长，因此这种情况下可以适当调大该参数。简单来说就是新来的机器需要初始化，连接上去初始化的超时限制的5倍的TickTime。</li><li>syncLimit<br>集群中Follower服务器与Leader服务器之间请求和应答之间能容忍的最多心跳数（TickTIme的数量），同步限制的时间。</li><li>集群节点<br>server.id &#x3D; host:port:port<br>id：通过在各自的dataDir目录下创建一个名为myid的文件来为每台机器服务一个服务器id，这个要自己去创建。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1645973579489-e56645bd-1c6a-4b91-9ee0-882a9f3006c3.png#averageHue=%23eeeeee&clientId=u0f708a63-ac69-4&from=paste&height=317&id=rQWda&originHeight=317&originWidth=1712&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70234&status=done&style=none&taskId=u5444b6e5-5769-4150-b3ab-c7126ff7fe9&title=&width=1712" alt="image.png"><br>    两个端口号：第一个Follower连接到Leader用的端口，第二个在选举Leader时用的</p><h2 id="连接集群"><a href="#连接集群" class="headerlink" title="连接集群"></a>连接集群</h2><p>集群的所有节点都可以提供服务，客户端连接时，连接串可以指定多个或全部集群节点的连接地址。如”10.168.1.23:2181,10.168.1.24:2181,10.168.1.25:2181”当一个节点不通的时候，客户端将自动切换到另一个节点。<br>zk对服务器的要求还是建议给予一个单独的服务器，硬盘没有什么需求，主要是内存有个2G+就可以了。</p><p>此处省略搭建过程，如有需要可以参考文档。</p><h2 id="集群监控"><a href="#集群监控" class="headerlink" title="集群监控"></a>集群监控</h2><p><a href="http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_monitoring">官方说明</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1646011844309-90af9673-de78-49e1-b1fc-8aa8dd55ab4f.png#averageHue=%23fcfaf9&clientId=u4ba4ea45-1c7d-4&from=paste&height=136&id=ue8af93ca&originHeight=136&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9306&status=done&style=none&taskId=ud13835c4-2ecf-4ad8-9224-3900b3512f3&title=&width=638" alt="image.png"></p><ul><li><a href="https://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_zkCommands">四字监控命令</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1646011949420-32194ba6-2d67-4808-b21b-a1b0da4f08cc.png#averageHue=%23f9f7f5&clientId=u4ba4ea45-1c7d-4&from=paste&height=930&id=ude960703&originHeight=930&originWidth=1748&originalType=binary&ratio=1&rotation=0&showTitle=false&size=194212&status=done&style=none&taskId=u03eba3ad-7843-454e-84d4-66144f8bcb7&title=&width=1748" alt="image.png"></li><li><a href="https://zookeeper.apache.org/doc/current/zookeeperJMX.html">JMX</a><br>zk支持使用JMX来进行监控。<blockquote><p>The Java JDK ships with a simple JMX console named <a href="http://java.sun.com/developer/technicalArticles/J2SE/jconsole.html">jconsole</a> which can be used to connect to ZooKeeper and inspect a running server. Once you’ve started ZooKeeper using QuorumPeerMain start <em>jconsole</em>, which typically resides in <em>JDK_HOME&#x2F;bin&#x2F;jconsole</em><br>When the “new connection” window is displayed either connect to local process (if jconsole started on the same host as Server) or use the remote process connection.</p></blockquote></li></ul><h2 id="集群-ZAB协议"><a href="#集群-ZAB协议" class="headerlink" title="集群-ZAB协议"></a>集群-ZAB协议</h2><p>ZAB协议（Zookeeper Atomic Broadcast ） ZK原子消息广播协议是专门为zk设计的一种数据一致性协议。<br>集群能够保证服务的可用性，容错性。集群中每一台服务器存储的都是完整的数据。那么集群中的节点如何保证这种数据一致性？并且为什么我们需要leader节点？<br>当客户端连接上集群之后，集群无外乎做两种操作，一个是读取，一个是更新。对于读取，在任何一个节点都是可以提供的。但是对于更新的请求，就不是随便哪个节点就可以完成的。更新的工作应该只能由leader节点统一负责，非leader节点接收到了更新操作都需要转交给leader节点统一操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1646012574045-c6230ae8-09be-4e18-a8c0-69f0aaffc066.png#averageHue=%23f8f8f8&clientId=u4ba4ea45-1c7d-4&from=paste&height=617&id=u50c78594&originHeight=617&originWidth=1385&originalType=binary&ratio=1&rotation=0&showTitle=false&size=157062&status=done&style=none&taskId=u2746ceae-e37a-4bfb-8cd5-2a902cda662&title=&width=1385" alt="image.png"><br>如图 read的请求可以直接访问db然后就返回出去了。但是写请求进来了就需要由leader接受并发起原子广播（Atomic Broadcast），超过半数的从节点同意更新，才会更新。</p><h3 id="同步过程说明"><a href="#同步过程说明" class="headerlink" title="同步过程说明"></a>同步过程说明</h3><ol><li>所有事务请求会转发给Leader节点</li><li>Leader节点会创建一个提议（Propose），这个提议会带上一个全局单调递增的事务id（zxid），然后广播出去。</li><li>Follower处理提议，并且作出反馈，是否同意这个提议</li><li>Leader节点收到过半反馈，广播commit。</li><li>Leader来response</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1646038677419-efa92c8d-710f-4ef4-bd70-20b181c2f62a.png#averageHue=%23f5f5f5&clientId=u510575cd-2d84-4&from=paste&height=677&id=u8846068a&originHeight=677&originWidth=1780&originalType=binary&ratio=1&rotation=0&showTitle=false&size=238675&status=done&style=none&taskId=ub0fd3a3b-8270-4cc2-b9d4-d9e2500f837&title=&width=1780" alt="image.png"><br>ZAB保证有序性这个重要的性质。</p><h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>除了保证有序性，ZAB协议还能为我们实现崩溃恢复。<br>Leader节点如果出现宕机，或者说由于网络问题原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。</p><ul><li>ZAB协议规定如果一个事务（Propose）在一台机器上被处理成功，那么应该在所有机器上都要被处理成功，哪怕是机器出现故障</li><li>ZAB协议确保了在Leader服务器上已提交的事务最终会再所有服务器上提交</li><li>ZAB协议确保丢弃那些只在Leader服务器上被提出的事务，意味着如果在提交之前leader宕机时候的提议都会被抛弃。</li></ul><p>所以ZAB协议设计的选举算法应该满足两点:</p><ol><li>确保提交 已经被leader提交的事务&#x2F;提议</li><li>确保丢弃 已被跳过的事务&#x2F;提议</li></ol><p>如果让Leader选举算法能够保证选举出来的新的Leader服务器拥有集群中所有机器最高的ZXID的事务Proposal，那么就能保证这个新选举出来的Leader一定具有所有已经提交的提案。如果让具有最高编号Proposal的机器来称为Leader，甚至可以省去Leader服务器检查Proposal的提交与丢弃。</p><h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p>Leader选举出来之后，Follower需要与Leader进行数据同步，当集群中半数节点完成同步，那么集群就可以正常提供服务。同步过程：</p><ul><li>Leader节点会为每个F提供一个队列，并将没有被F节点同步的事务以Proposal的形式逐个发送到F节点，并在每一个Proposal消息后面在发送一个commit消息，用以表示该事务已被提交。具体来讲就是如果zxid最到到10，如果F连接上来是8，L提供的队列里面就是9的Proposal，然后是9的commit，再是10的Proposal，然后再是10的commit，F就会从这个列表中取出数据同步到自己的服务上。</li><li>F服务器将所有未同步的事务都从L节点上同步过来并成功应用到本地数据库中，L服务器会将F加入到真正可用的节点列表中，才开始其他流程。</li></ul><h3 id="丢弃事务提案处理"><a href="#丢弃事务提案处理" class="headerlink" title="丢弃事务提案处理"></a>丢弃事务提案处理</h3><p>通过前面的学习我们知道，全局单调递增的事务ID - ZXID 非常重要，上面的实现全是建立在这个基础之上的。所以我们来了解一下这个zxid。<br>在ZAB协议中的事务编号ZXID设计中，ZXID是要给64位的数字：</p><ul><li>低32位 是一个简单的单调递增计数器。针对客户端的每一个事务请求，L服务器在产生一个新的事务提案的时候都会对该计数器进行+1操作</li><li>高32位 代表了Leader周期纪元的编号。每当选举产生一个新的L服务器，就会从这个L服务器上取出其本地日志中最大事务提案的ZXID，并从中解析出纪元值，再对其进行+1操作，以新值作为新的纪元，再将低32位置零开始生成新的ZXID。</li></ul><p>基于这样的策略，当一个包含了上一个Leader周期中尚未提交过的事务提案的服务器加入到集群中时，此时集群中已经有L节点了，自身以F的身份加入集群连接上L之后，L节点会更具自己服务器上最后被提交的提案和F上的提案对比，如果发现F上有上一个Leader周期的事务提案，L会要求F进行回退，回退到一个确实被集群中过半机器提交的最新的事务提案。<br>这就完成了丢弃事务提案的操作。也正是由于ZXID设计的巧妙性，才能完成很多操作。</p><h3 id="选举要求"><a href="#选举要求" class="headerlink" title="选举要求"></a>选举要求</h3><p>关于对选举算法的要求：</p><ol><li>选举出的L节点要持有最高的ZXID</li><li>过半数节点同意</li></ol><p>只要满足这两个要求，你可以自己去实现选举算法。<br>ZK内置的选举算法实现：</p><ol><li>LeaderElection</li><li>FastLeaderElection(默认)</li><li>AuthFastLeaderElection</li></ol><p>我们可以从日志里面也可以发现选举的部分信息<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1646056189216-07abd47c-00dd-47e4-adbc-a7f4b7f03625.png#averageHue=%23171717&clientId=u510575cd-2d84-4&from=paste&height=576&id=u66f7d402&originHeight=576&originWidth=1292&originalType=binary&ratio=1&rotation=0&showTitle=false&size=169214&status=done&style=none&taskId=u69132217-2797-4e73-a42d-0357b167553&title=&width=1292" alt="image.png"></p><h3 id="选举机制概念"><a href="#选举机制概念" class="headerlink" title="选举机制概念"></a>选举机制概念</h3><p>选举中的几种概念</p><ol><li>服务器id myid</li><li>事务id，服务器存放的最大ZXID</li><li>逻辑时钟，发起的投票轮数计数，表示时第几轮的投票。有可能在指定的时间周期内选举不出L节点，需要发送第二轮甚至第三轮的情况，这个时候可能会收到之前的投票情况反馈，比如第二轮投票开始了才收到第一轮的投票反馈，这时候第一轮的票肯定是要作废的。</li><li>选举状态<ol><li>Looking ，竞选状态</li><li>Following，随从状态，同步Leader状态，参与投票</li><li>Observing，观察状态，同步Leader状态，不参与投票。集群太大的时候竞选过程会变得很耗时，所以不需要所有节点都要投票。设置这种状态能有效提高效率</li><li>Leading，领导者状态</li></ol></li></ol><h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><ol><li>每个实例都发起选举自己作为L的投票（自己投票给自己）</li><li>其他服务实例收到投票邀请，比较发起者的事务ID，投较大的那一方，如果相等就比较发起者的服务ID，投较大的一方</li><li>发起者收到大家的投票反馈，看投票数（含自己的票）是否大于集群的节点数的半数，大于就选举成功，担任领导者。未超过半数且领导者未选出，则再次发起投票。</li></ol><p>选举完成的条件就是有节点拥有半数的票。</p><h4 id="流程示例"><a href="#流程示例" class="headerlink" title="流程示例"></a>流程示例</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1646057062009-3b5671bc-52f2-41eb-b42f-b9d909e69746.png#averageHue=%23eeeeee&clientId=u510575cd-2d84-4&from=paste&height=789&id=u8f617345&originHeight=789&originWidth=1674&originalType=binary&ratio=1&rotation=0&showTitle=false&size=355624&status=done&style=none&taskId=u5a0d2076-5286-4c09-9da0-6f78307c7e3&title=&width=1674" alt="image.png"><br>ZK在CAP理论保证了CP，且C只保证了顺序一致性。一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）在选举的时候ZK是不可用的。<br>关于ZK的理论知识部分就大致讲完了，ZK本来不是一个很复杂的组件，工作中如果遇到问题的话，多思考多看看官方文档就OK了。</p>]]></content>
    
    
    <categories>
      
      <category>middileware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>middileware</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka</title>
    <link href="/2024/06/16/kafka/"/>
    <url>/2024/06/16/kafka/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>Kafka是linkedin使用Scala编写具有高水平扩展和高吞吐量的分布式消息系统。目前的Kafka是scale和java混合编程实现的。<br>Kafka对消息保存时根据Topic进行归类，发送消息者称为Producer，消息接收者称为Consumer，此外Kafka集群由多个kafka实例组成，每个实例（server）称为broker。<br>无论是Kafka集群，还是producer和consumer都依赖于zookeeper来保证系统可用性，zk为集群保存一些meta信息。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647219047197-c01b0b5f-40f5-4acd-8bdc-9ad8a39d54d4.png#averageHue=%23dddddd&clientId=ue82b16c4-1585-4&from=paste&height=284&id=u6177d17c&originHeight=284&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54990&status=done&style=none&taskId=ud338bb68-555b-4bce-8757-1f4b665ecfd&title=&width=853" alt="image.png"></p><h1 id="主流MQ的对比"><a href="#主流MQ的对比" class="headerlink" title="主流MQ的对比"></a>主流MQ的对比</h1><p>kafka可以作为大数据系统的组件，正是因为kafka的高吞吐量的特性。<img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647219282859-742854b7-a65a-4bbe-adf5-191e0d4f078d.png#averageHue=%233a8bce&clientId=ue82b16c4-1585-4&from=paste&height=713&id=u3a084205&originHeight=713&originWidth=1770&originalType=binary&ratio=1&rotation=0&showTitle=false&size=471206&status=done&style=none&taskId=u0d4c9f17-d407-4163-9035-98a84c36a00&title=&width=1770" alt="image.png">吞吐量方面：kafka&gt;RabbitMQ&gt;ActiveMQ<br>数据可用性、准确性保证：RabbitMQ&gt;ActiveMQ&gt;kafka<br>kafka注重批量数据，具有高可用（HA）、高水平扩展、高吞吐量的特性。kafka使用的是仿AMQP协议，在AMQP的基础上进行了修改。<br>集群方面，支持但不擅长意味着如果要进行集群就需要耗费相当的精力，可能也不方面扩展。而kafka天生就是以集群的方式存在，线上使用3个kafka集群才是对它的尊重。<br>再拿RocketMQ来对比一下，RocketMQ是阿里在kafka的基础上进行重写实现，所以很多方面都和kafka类似：数据的堆积、大吞吐量。它们两个最大的区别在于场景的适用。RocketMQ会更擅长业务系统，对事务支持很好，而Kafka更擅长数据领域，更关注数据的吞吐。</p><h2 id="Kafka主要特性"><a href="#Kafka主要特性" class="headerlink" title="Kafka主要特性"></a>Kafka主要特性</h2><p>官网称kafka是一个流处理平台，流平台需要如下特性：</p><ul><li>可发布和订阅流数据，类似于消息队列或者消息级消息系统</li><li>以容错的方式存储流数据。关键在于存储二字，kafka可以存储数据。</li><li>流数据产生时就进行处理。kafka提供了一些api（Stream API），可以实现在数据进入在kafka之后不直接消费，而是在topic之间进行数据的处理，比如数据清洗，这样消费者可以消费到被处理过的数据。</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>基于kafka构造实时流数据管道，让系统或应用之间可靠地获取数据；<br>构建实时流式应用程序，处理流数据或基于数据做出反应。流数据意味着数据不断产生，不断被处理。在处理数据的时候，可以判断出数据的类型，基于不同的数据做出不同的处理反应。如果消费数据中出现了问题，可以从某个点重新消息纠正，这也是流式应用程序的特点，既可以实时消息，也可以从之间某个数据点重新消费。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>kafka实现的是仿AMQP协议，那我们先来看看什么是AMQP协议。</p><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>AMQP（Advanced Message Queuing Protocol）是一个提供统一消息服务的标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件而设计。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647220807463-f84c021c-09de-42f5-a43b-1bc76c0048c1.png#averageHue=%23f2f2f2&clientId=ub6769867-b391-4&from=paste&height=195&id=LjHoD&originHeight=195&originWidth=1310&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52942&status=done&style=none&taskId=ub95c3417-8b3e-4f41-bcaf-15412eb28dd&title=&width=1310" alt="image.png"><br>server：AMQP服务器，接收客户端连接，实现AMQP消息队列和路由功能的进程<br>producer：生产者，向Broker发布消息的客户端应用程序<br>consumer：消费者，向消息队列请求消息的客户端应用程序</p><p>kafka仿AMQP，在于kafka的broker是以集群的形式存在，push 和pull操作的都是broker集群。除此以外，kafka是以多播的形式进行的，ActiveMQ和RabbitMQ的消息无论是排队（queue）还是多播消费方式只能被消费一次，而kafka是durable的，消息会存在堆积，那么消息就可以被消费多次，并且kafka还能做到广播消费。</p><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>数据主题，是kafka中用来代表一个数据流的一个抽象。发布数据时，可以用topic对数据进行分类，也作为订阅数据时的主题。一个Topic同时可以有多个producer、consumer。</p><h3 id="Partation"><a href="#Partation" class="headerlink" title="Partation"></a>Partation</h3><p>每个partition时一个顺序的、不可变的record序列，partition中的record会被分配一个自增长的id，我们称之为offset。</p><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>每条记录都有key、value、timestamp三个消息<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647228049364-11b89b53-c308-4a7e-87c5-aea09be1bbec.png#averageHue=%23f3f3f3&clientId=ub6769867-b391-4&from=paste&height=412&id=u9cd6aa1c&originHeight=412&originWidth=1347&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105243&status=done&style=none&taskId=u73acc42a-687a-42f1-a255-4796667f6e6&title=&width=1347" alt="image.png"><br>消息在Partition不断递增， 且有序有唯一ID，但是这个有序只保证在Partition层面上的，topic级别以上都不保证有序了。如果你想要保证topic级别下有序，额那就让topic只有一个partition就可以了。其实很多时候我们只需要保证一类数据的有序性，利用hash（key）%Count（partition）将同类的数据放到同一个partiton就可以保证数据的有序性。比如交易数据，我只需要保证股票类有序，基金类有序，而不需要保证全部的有序。</p><p>那么在kafka中如何定位一条数据呢？Topic:Partition:offset。</p><h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>每个partition还会被非制导其他的服务器作为replication，这是一种冗余备份策略。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647227997992-0d358483-c078-435e-a865-113bf28e649a.png#averageHue=%23d5d5d5&clientId=ub6769867-b391-4&from=paste&height=342&id=p1wNv&originHeight=342&originWidth=1535&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100330&status=done&style=none&taskId=u3cbc2453-0797-4e7d-baf6-f1a922a10c2&title=&width=1535" alt="image.png"></p><p>假如总共有12T的数据需要被存储处理。每个机器只有3T的磁盘容量，那么数据就应该被分成4分，被存储到4个机器上，每份都是3T，我们称其为<strong>数据分片</strong>。每个数据分片都不是完整的数据，4个分片合并才能被称为是完整数据。通过这样的数据分片，我们存储起来了单个机器不能存储的大数据。并且我们提高了并发级别：如果是使用一台能存储12T的数据的机器，那么只能实现单个机器上处理。而分了4个分片之后，原先只能在一个机器上完成的操作，我们能实现4个分片同时处理，且服务器的压力也被分散了，提高了并发级别，读写性能。降低了数据丢失的风险，如果12T数据出现数据损坏，那么整个12T数据将不可用，分为4个分片将这种风险也降低了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647226891322-81ce1eec-1c72-40e0-850e-dfb30134c4ca.png#averageHue=%23f8f8f7&clientId=ub6769867-b391-4&from=paste&height=377&id=u3988b90e&originHeight=377&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126331&status=done&style=none&taskId=u6d5d214e-8c4c-44b5-bc9e-860318ac899&title=&width=957" alt="image.png"><br>在此基础上难道没有缺点吗？最大的问题就是数据的可用性非常差。如果分片所属的机器宕机了，那么上面的数据就完全不可用了，并且整个数据的完整性都失去了，这就是可用性差。为此我们将每个机器存储设置为6T，这样每个机器就能多存一份其他分区的备份。对外提供服务的partition（如图中的p0-p3）被称为 Leader Partition ，kafka集群中的leader指的就是这个Leader Partition（LP），这个leader和follower的概念和其他的MQ是有所不同，而Replication Partition（RP）就是Follower Partition（FR）。kafka中的FR只是冗余备份，不提供任何服务。只有在LP宕机之后才由FP来提供，如果由多个FP那么就选举出一个新的分片来做LP去提供服务。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647227542002-b99c3878-7768-4527-8496-dfd0c0ea0eb5.png#averageHue=%23f6f5df&clientId=ub6769867-b391-4&from=paste&height=520&id=u3d1991bd&originHeight=520&originWidth=1113&originalType=binary&ratio=1&rotation=0&showTitle=false&size=179244&status=done&style=none&taskId=u584358e1-d3b9-4e4f-bf24-4951c9fe1aa&title=&width=1113" alt="image.png"></p><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><p>kafka有四个核心api：</p><ul><li>producer：允许一个应用程序发布一串流式的数据到一个或者多个kafka topic。</li><li>consumer：允许一个应用程序订阅一个或多个topic，并且对发布他们的流式数据进行处理</li><li>streams ：允许一个应用程序作为一个流处理器，消息一个或者多个topic产生的输入流，然后生产一个输出流到一个或多个topic中去，再输入输出流中进行有效的转换。</li><li>connector：允许构建并运行可重用的生产者或者消费者，将kafka topic连接到已存在的应用程序或者数据系统。比如连接到一个关系型数据库，捕捉表的所有变更内容。方便我们连接数据库或其他中间件，比如mysql，redis。这种从别的系统种读取进入kafka的接口在connector称为source，而往外写数据的接口称为sink。这个connector经常被用来数据同步并做数据清洗。</li></ul><p>你可能会对streams API有疑问，我好像自己可以通过producer和consumer来实现类似stream的功能，为什么还要提供一个streams这样一个API呢？<br>实际上streams就是通过producer和consumer来实现的。streams api的作用在于简化topic传递数据之间进行类似java stream一样的操作，封装了这种stream的算子（join、group、filter），这样我们更能集中在数据处理本身。</p><p>下面将详细介绍一下几个API，但是使用的就不会详细说，使用方式基本都是引包然后写点图中差不多的代码，主要是以理解工作原理为主。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1980660/1623634608725-a7a483d6-b22e-4af8-bbda-c9153e2bd869.png#averageHue=%23dedede&height=384&id=ddLyI&originHeight=384&originWidth=1396&originalType=binary&ratio=1&rotation=0&showTitle=false&size=174665&status=done&style=none&title=&width=1396" alt="image.png"><br>重点是需要理解下面三个配置： </p><ol><li>batch.size  : Producer会为每个partition维护一个buffer缓冲，用来记录还没有发送的数据，每个缓冲区内存大小用batch.size指定，默认是16k。由于每个partition都有自己的buffer，那么在此时保证了有序性。如果消息的大小超过了buffer的大小，那么消息将不会经过buffer，直接发送出去。</li><li>linger.ms : linger.ms为buffer中的数据在达到batch.size前，需要等待的时间，即buffer的数据最多等待多久发送出去。如果没有配置这个值，那么消息会被直接发送出去，而不需要等到buffer打满。</li><li>asks<br> acks用来配置请求成功的标准</li></ol><ul><li>0：不考虑服务端的响应，直接放到buffer后返回，吞吐量非常大，可用性保证就很差。这种一般用于日志数据。</li><li>1：当写入leader partition成功之后就返回</li><li>all：需要replication写入成功才会返回</li></ul><ol start="4"><li>retries 如果发送消息失败的重试次数</li></ol><p>acks和send方法放到buffer是没有关系的，acks描述的是buffer发送到partition（leader partiton、replication partition）是否成功的返回。设置为1或者all的时候，要等待得到了正确的响应之后，后面batch的数据才会发送出去不然就会阻塞等待直到OOM。<br>每一个partition都有自己对应的buffer。send的方法是异步的，它负责将数据发送到buffer中，producer中的background IO线程来负责发送到partition，这种方式也是提高了吞吐量，于此同时我们也应该注意的是send方法并不一定会成功。<br>partition的个数越多并发量就越高。<br>推送消息有两个条件：buffer满了或者是linger.ms等待时间到了，谁先达到等待条件就被推送。</p><hr><p>指定partition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">consumer.assign(Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicPartition</span>(<span class="hljs-string">&quot;market_topic&quot;</span>,<span class="hljs-number">0</span>)));<br></code></pre></td></tr></table></figure><p>指定offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//指定offset。seek一定要在poll方法调用之后才能拿到，否则抛出异常</span><br>Set&lt;TopicPartition&gt; assignement = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>      <span class="hljs-keyword">if</span>(assignement.size() == <span class="hljs-number">0</span>)&#123;<br>          consumer.poll(<span class="hljs-number">100</span>);<br>          assignement = consumer.assignment();<br>      &#125;<br>      System.out.printf(<span class="hljs-string">&quot; === consumer assignment : %s \n&quot;</span>,assignement);<br>      consumer.seek(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicPartition</span>(TOPIC,<span class="hljs-number">0</span>),<span class="hljs-number">10</span>);<br><br></code></pre></td></tr></table></figure><h3 id="Consumer-API"><a href="#Consumer-API" class="headerlink" title="Consumer API"></a>Consumer API</h3><p>producer api相对来说会比较简单，consumer是kafka比较复杂的一块。<br>我们知道kafka是一个集群，每个broker上数据都不是完整的，每个机器会存储别的分片数据的备份（replication）来提高可用性。kafka使用zk来存储元数据，比如 broker ID、 HostName、IP:Port，topic的名字，每个topic有多少个Partition，Replication及保存在哪个broker上<br>等元素据都会交由zk来存储维护。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647479064852-6fadcee9-2987-45f2-a2ff-e7a3dc3dff37.png#averageHue=%23e9e9e9&clientId=u3412e353-d070-4&from=paste&height=453&id=u02b3d24a&originHeight=453&originWidth=853&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103790&status=done&style=none&taskId=u8f18e2c1-5620-4a8a-9c80-aeb0744fc87&title=&width=853" alt="image.png"><br>提一句，zk是一个分布式信息协调服务，注册中心、配置中心都只是其中一种用法。zk集群和kafka 、HDFS、ES集群最大的不同就是，zk集群中的每一个节点存储的数据都是完整的，其他的只是存储了一部分数据，是不完整的。zk在设计的时候不追求性能，更保证数据的高可用、数据一致性，每次写入数据都是一个事务，真正做到只有所有zk节点写入同步成功才会返回写入成功，基于这个原因，zk节点越多性能会越差。我们增加zk节点是为了集群的可用性，容灾，而不是为了提高zk的性能。更多zk内容可以看看zookeeper。这里讲的可用性其实是CAP中的P，即分区容错。</p><p>kafka的消费方式和其他的传统MQ（Active）消费方式有所不同。pub数据到ActiveMQ到sub出去拉取被消费，不管是广播还是队列（queue）的消费方式，消息始终只能被消费一次。但是kafka中，因为消息在kafka是会落地的，只要不被清理，数据会一直存在，消费者就可以从特定的点消费，那么消息是可以被消费多次的。<br>在kafka中有个consumer group的概念，里面可以存在多个消费者。每个consumer有且只能消费一个partition，这种使用group的方式可以很好地提高了并发量，且并发度间接受到partition的控制。而partition可以被不同group的consumer消费，但是同一个group下只能被一个consumer消费。这样的机制使得在不同group下的consumer能够消费相同的partition，这样就做到了多次消费。如果group中的consumer数量多余partition，那么多出来的一个consumer会“饿死”，貌似久了会报错，所以一般consumer数量会设置比partition数量少。如果consumer的数量比partition少，那么多的partition会分配给谁这个是随机的，不知道是否可以指定。<br>group中consumer如果挂掉了，那么group会帮我们做容错，分配给正常的节点。且进度并不会从新开始而是继续消费，如果从头消费，那么就可能是我们不希望看到的重复消费了。这个消费进度并不是存在客户端，不会随着客户端宕机而消失。<br>kafka的consumer都是以group的形式来存在的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647500814342-04b5b7bb-a558-4d8b-9037-09d111a218f5.png#averageHue=%23f7f4f4&clientId=u93a9fbe0-b705-4&from=paste&height=562&id=u0aa39059&originHeight=562&originWidth=1307&originalType=binary&ratio=1&rotation=0&showTitle=false&size=238606&status=done&style=none&taskId=ud1c0de80-f712-412c-91ef-50c921440c0&title=&width=1307" alt="image.png"><br>考虑一个问题，即使不使用group的概念，我们限制一个consumer只能消费一个partition，这样也是可以做到快速消费和负载均衡的。实际上group的作用更多的不同的消费需求做消费（进度）隔离，实现重复消费。在kafka中partition里面数据有offset的概念，每个offset（偏移量）下就是代表的一个记录、一条数据。我们直到通过topic+partitionId+offset可以定位一条数据，每个consumer在消费的时候会有自己的消费进度。可能比如 p1:8 ；p2:1;p3:1;p4:0  表示partition1 消费到第8条数据,p2消费到1以此类推。不同的group可能会存在消费进度不一样的情况。groupId相同的consumer属于同一个group，同一个group下共享一个消费进度，所以消费进度是包含了所有partition的消费情况的（即P1-P4，而不是独立开来，这点要确认）。在kafka早期的版本这个消费进度是保存在zk中，因为这个消费进度会频繁更新，zk的压力会增大，后来kafka使用了一个专门的topic（_offset_topic_）来存储。<br>更准确一点，保存的消费进度需要有什么东西呢？groupId,topic_name,partition_id,offset。宕机之后接收的consumer就能通过这些信息继续消费。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647499831481-db7e1909-f57d-4aaa-a700-60ab080ec524.png#averageHue=%23f7f7f7&clientId=u93a9fbe0-b705-4&from=paste&height=543&id=u3eefc778&originHeight=543&originWidth=1323&originalType=binary&ratio=1&rotation=0&showTitle=false&size=195767&status=done&style=none&taskId=u5514e46b-35fc-4935-b06f-07b2a7bbafd&title=&width=1323" alt="image.png"></p><p>实例代码：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647506436655-6783d8cc-7d83-424c-bef5-231aad212651.png#averageHue=%23fdfcfb&clientId=u0a311782-ace7-4&from=paste&height=754&id=u4ec02400&originHeight=754&originWidth=1813&originalType=binary&ratio=1&rotation=0&showTitle=false&size=637597&status=done&style=none&taskId=uf38fae56-410b-4596-a114-83455cdabc1&title=&width=1813" alt="image.png"><br>prop中有个key.deserializer和value.deserializer，数据在kafka以二进制的方式存在磁盘，我们传送过来的数据可能是各种类型，String、Double都可能，这时候我们需要进行序列化，在producer端进行序列化，消费者端进行反序列化。这是个加密解密的过程。这个过程包括两个过程，一个key，一个value，为什么会有两个东西呢？难道kafka的存储方式是K-V的形式存储的？如果是K-V存储方式，那么这个K-V的key和代码中的key是同一个东西吗？K-V的value是消息本身，那么K自然是要能唯一标识这个消息的K，我们直到在kafka中唯一标识消息的东西是topic\partition\offset这三样组成，所以这个K就应当是这三个东西，但是实际上实现可能并不是这样，我们所说的topic\partition\offset是一种方便我们理解的一种逻辑上的表达。但实际上kafka并不是K-V的存储，并不能通过K去查询。而props中的key和kafka的K-V没有任何关系。<br>像实例代码中key就是写死的常量。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647507391615-5bd4152d-98e3-4232-b4ce-fd23e984990a.png#averageHue=%23fdfbf7&clientId=u0a311782-ace7-4&from=paste&height=150&id=u6c68718f&originHeight=150&originWidth=1084&originalType=binary&ratio=1&rotation=0&showTitle=false&size=66709&status=done&style=none&taskId=uf317c64f-a91a-42e1-a0d8-55bea4c261b&title=&width=1084" alt="image.png"><br>我们在往kafka写入数据的时候，可能存在多个partition，那么就设计消息分发，我们可能希望某个消息固定发送到一个partition上，那么这个key就是用在这个时候，如果key&#x3D;null，代表的是轮询partition存储，当key!&#x3D;null的时候就是做hash计算%count(partitions)。这个是key的作用。这就是为什么每次使用kafka去写入数据都可以决定写不写这个key，kafka对这个key的要求不严格，甚至key是同一个。估计是因为同时配置了key和value，让人不禁想起了map这种基础的结构带来了误解。我们也可以指定partition。key可以帮助我们控制数据写入的方式，间接上控制了数据的顺序。<br>poll方法可以传入一个timeoutMs，在没有到达超时时间，客户端会保持长连接直到超时，减少连接的次数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647508576860-7e87403d-17bf-46a3-acfe-96da4eff9d7d.png#averageHue=%23f2f1e1&clientId=u0a311782-ace7-4&from=paste&height=594&id=u9d52f02e&originHeight=594&originWidth=1226&originalType=binary&ratio=1&rotation=0&showTitle=false&size=408201&status=done&style=none&taskId=u1b9b604f-8c83-4176-bf8c-7dc6485a610&title=&width=1226" alt="image.png"><br>我们接收到的是ConsumerRecords对象，api就不过多介绍了。<br>关注这行代码：<code>props.setProperty(&quot;enable.auto.commit&quot;,&quot;true&quot;)</code> 这个并不是一个ack，而是commit消费进度，这里代表是自动提交消费进度。<strong>自动提交会在每次poll的时候会将上次的消费进度提交过去</strong>。正常关闭consumer的话在关闭的时候也会提交消费进度。<br>这个autocommit有个两个坑：</p><ol><li>会导致重复消费问题。在最后一次处理完数据，刚刚好写入DB完成之后，consumer宕机了，那么22就没有被提交到服务端，服务端只有16，那么就会重复拉取17-22的数据，那么DB就可能出现两次数据。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647567397657-3cd1cce7-ef9a-45a8-9f19-97a03511c579.png#averageHue=%23f4efee&clientId=u93b90d58-7339-4&from=paste&height=866&id=g1Mus&originHeight=866&originWidth=1430&originalType=binary&ratio=1&rotation=0&showTitle=false&size=439528&status=done&style=none&taskId=uc951d299-d084-487b-8121-532c66f2614&title=&width=1430" alt="image.png"></p><ol start="2"><li>同样是自动提交，但是这次是我们设置了个<code>minBatchSize</code>，用意是当数据满足20+条的时候才插入到DB中。如果此时你还是使用自动配置的设置，那么两边的落地的方式时不一致的。kafka依然是提交上一次的，而DB却是分批次提交，这样就可能出现一边提交一边未提交的情况，在这段时间如果系统出现故障，那就出现了不一致的问题。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647568917802-845217f4-8a49-4eec-8fb7-66957282a4e3.png#averageHue=%23fcfcfb&clientId=u93b90d58-7339-4&from=paste&height=859&id=ub5e483b1&originHeight=859&originWidth=1550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=790909&status=done&style=none&taskId=u69d883e7-8997-4e35-ab43-7d7a209a0ac&title=&width=1550" alt="image.png"><br>这个问题只要不自动提交就能处理。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647587716305-40cf46bc-8f41-4021-8e18-2e3fc09f01db.png#averageHue=%23fcfcfa&clientId=u231c5563-e539-4&from=paste&height=847&id=u98a70409&originHeight=847&originWidth=1704&originalType=binary&ratio=1&rotation=0&showTitle=false&size=704727&status=done&style=none&taskId=u7bba69fa-0fb0-4b3f-8275-96092882a59&title=&width=1704" alt="image.png"><br>从上面两个例子我们可以看出来，自动提交存在的问题还是比较大，数据如果比较重要的话，还是自己手动控制提交的好。AutoCommit给予我们的只是操作上的方便而已。虽然还是分了两步，但是比自动提交稍微可控一点。我们不必害怕插入失败commit成功的问题，因为只要加个判断，在insertiToDB成功才commit进度的方式就能避免这个问题。不要考虑使用事务控制，因为kafka所解决的问题吞吐量大，如果使用事务那就有点反其道而行之的感觉了。但是有可能出现insertDB成功，但是commit失败的情况，这种情况就会出现数据重复的问题，的确需要处理，DB做幂等性控制，比如设置唯一主键的方式，让kafka过来的重复数据无法commit，但是这种做法又会影响到insertDB成功之后commit的流程，不太好解决。<br>手动提交保证的语义是at least once，即最少一次。而自动提交会出现丢数据也会出现数据重复的问题。</p><p><strong>我们要怎么样保证消费数据恰好落地一次，消费一次呢？</strong><br>那我们就需要就需要做到数据落地以及消费进度提交两个操作的原子性，这样就可以保证exactly once。<br>有个方案，我们把数据落地到mysql，那么就需要设计这样的表，第一列存储kafka Info，这个kafka info就是当前的offset，我们每一次把数据都往mysql写的时候，要知道数据都有对应的partition和offset，这个kafka info就是当前数据的pid和offset。当topic确认之后，通过pid和offset唯一确认一个数据。<br>这种做法等于说是用来解决我们上面提出的幂等性控制问题， 如果我们直接对消息落地的表操作，那就会出现影响程序流程的问题，那么以这种引入第二张表的形式来控制。这种做法，我们可以不用是消息进度落地，却能够让数据落地，并且记录了消费进度与数据的关系。当consumer宕机后重新启动消费的时候，我们就可以去差这个表，查到对应pid中的消费到哪个offset，就可以接着消费，这样就不会重复消费，也不会丢失数据。消费进度和数据落地在这张表和为了一个操作，并且没有依赖事务，所以不依赖能提供事务的mysql等工具，在某些不支持事务的工具中（hive）也能实现。注意的是consumer重新启动的时候就需要先去这个表里面查询。现在看来是比较理想的解决方案。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647653848911-08fb8a05-8165-4a50-bc49-b8d5ee0ccfab.png#averageHue=%23f7f7f7&clientId=uad2d1815-38f4-4&from=paste&height=784&id=ucd395811&originHeight=784&originWidth=1425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=131743&status=done&style=none&taskId=ub7fbfced-b5b3-451a-b770-66fa4d75129&title=&width=1425" alt="image.png"></p><p>我们使用自动或手动地提交进度，甚至在外部保存消费进度，主要目的就是为了重新消费的时候，知道从哪里开始消费。</p><p>kafka中怎么样做到数据不丢失？<br>ACK 设置成all， 保证消息存储到replication partition。设置合理ISR，保证多个replication partition都同步LP成功。</p><h3 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h3><p>stream api是用来做流处理的,不间断地处理数据。<br>那么流程序的作用或者意义是什么呢？（java lambda 是一种语法，和流处理没有太大的关系）<br>流程序是和批处理程序相对的。数据一般以流的形式产生的，在传统处理方式中，不断产生的数据会被累计起来，成为一个大的数据集（Master DataSet），那么我们就对这些数据进行批处理（Batch），得到新的结果集（PreComputed views），然后我们就可以展示或者查询、使用这个结果集。这种批处理的处理方式存在一个问题，那就是数据存在延迟，数据的产生和结果查询存在时间差，不是实时的。且数据量一般会很大，都是在夜间进行数据抽取，防止影响业务正常运行。流处理就是为了补充这个实时性处理问题，在数据产生的时候就开始不停地process，并且实时地写入到增量的结果集（increment），这个结果集也是要支持实时写入，这个结果集在实时变化，进行查询得到的也是实时的数据。这就是流程序的作用。<br>这种架构就是Lambda架构。和java lambda是没有关系的。在以前流程序是不稳定的，很有可能一个错误的数据就导致系统崩溃，所以批处理和流程序一起合作处理，批处理保证数据一定会存在，而流处理保证数据的实时性。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647655810386-1c86ac8d-dc80-4a81-a306-95020f4d7881.png#averageHue=%23f9f8f8&clientId=uad2d1815-38f4-4&from=paste&height=756&id=u8add80e3&originHeight=756&originWidth=1862&originalType=binary&ratio=1&rotation=0&showTitle=false&size=234184&status=done&style=none&taskId=u0c9f427a-4f84-4721-9202-b78a0f0cc7a&title=&width=1862" alt="image.png"><br>比较麻烦的是，我们要同时维护两套系统，无论系统业务逻辑变更、新增都需要对两个系统做维护，比较麻烦。<br>kafka的流程序可能是比较简单，并没有什么值得讨论的东西。<br>当前流行的架构是Flink或者Spark。流程序的数据会被放入到kafka里面，起到流数据存储的作用，数据会在kafka落地并保证顺序，然后使用比较流行的大数据技术，比如早期的spark 或 出现的较晚但是阿里在推的Flink，它们基于一套api就能实现流处理和批处理，所谓流批一体。Spark的流批一体做的没有Flink完善，Flink的有点就是这，这种架构省去了两次开发的麻烦。并且没有kafka，spark&#x2F;Flink如果顶不住或者其他的情况宕机了，那么数据就真丢了，有了kafka之后就算宕机了，重新启动再消费就行了。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647656288234-e0b38ceb-ab5e-4cf8-81c2-de13199a3974.png#averageHue=%23fbfbfb&clientId=uad2d1815-38f4-4&from=paste&height=743&id=ud348af7f&originHeight=743&originWidth=1800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=163564&status=done&style=none&taskId=ub62bf5f2-4390-49c3-8230-105a9b5cbcb&title=&width=1800" alt="image.png"></p><p>正统的流处理程序有 Spark、Flink、Storm。这些平台的使用都是有成本的，都是需要从新搭建的。kafka的stream api就是个java程序，使用起来方便。这可能就是kafka为什么自称能做流处理的原因吧。<br>api的使用就不多讲了，直接看看代码：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647658566634-8adccad3-751b-42f6-9a72-03c8d447d56b.png#averageHue=%23f2f0e5&clientId=uad2d1815-38f4-4&from=paste&height=779&id=u692cfc5e&originHeight=779&originWidth=1432&originalType=binary&ratio=1&rotation=0&showTitle=false&size=758215&status=done&style=none&taskId=u5de71d45-bc24-46a1-90d8-b4b668c8388&title=&width=1432" alt="image.png"><br>介绍一下，首先要写一些配置参数，比如程序名称，连接参数，key value的序列化。创建一个KStream。stream api需要从一个input topic输入，然后输出到一个output topic，这两个都需要配置，<code>KStream&lt;String,String&gt; textLines = builder.stream(stram-plaintxt-input)</code> 就是指定了input topic，这样我们就拿到了一个流，接下来对流进行处理。示例代码我们是想进行count，count完成放到一个topic中。<br>可以自己试着实现一个，跑一下理解会更深刻。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>kafka的应用场景比较多，这里详细介绍一下，大多数情况下是作为带存储的消息队列在使用，官方说可以作为流数据处理平台。</p><h2 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h2><p>消息系统被用于各种场景，如解耦数据生产者，缓存未处理的消息。kafka可以作为传统消息系统的替代者，与传统消息系统相比，kafka有更好的吞吐量、更好的可用性， 这有利于处理大规模的消息。还有更大的区别在于消费者方面，具体可以看consumer。<br>根据经验，通常消息传递对消息吞吐量要求比较低，但可能要求较低的端到端延迟，并经常依赖kafka可靠的durable机制。<br>在这方面，kafka可以和传统的消息传递系统ActiveMQ和RabbitMQ媲美。高并发的场景下，其他的MQ在放入到MQ（partition级别）时还能做到保证有序，但是高并发多个消费者消费的情况下（异步），是没有办法保证消息消费的顺序的。而kafka在消费端可以通过一个消费者消费一个partition的方式保证消费有序。值得注意的是这种保证顺序的方案。</p><h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>写入到kafka上的数据是会落地到磁盘上的，并且有冗余备份，kafka允许producer等待确认，通过配置，可实现直到所有的replication完成复制才算写入完成，这样可以保证数据的可用性。<br>Kafka认真对待存储，并允许client自行控制读取位置，你可以认为kafka是一种特殊的文件系统，它能够提供高性能、低延迟、高可用的日志提交存储。<br>kafka使用了顺序读与顺序写，所以很快。实际上kafka的存储是建立在<strong>磁盘+内存</strong>两者上，同时实现的高速读取与写入，最终落地磁盘，这样就能实现数据重复消费。<br>kafka是一种<strong>流存储</strong>系统，和其他传统的数据存取系统相比（hdfs、mysql），流存储的特别是保证了数据落地的顺序，这样流程序消费数据的时候就能进行数据回溯，即如果数据在某个点出现问题，那么程序能够找到错误的点，从这个数据点开始继续往前消费，甚至可以从整个数据从头开始消费（回放），这就是顺序存储的好处。</p><h2 id="日志聚合"><a href="#日志聚合" class="headerlink" title="日志聚合"></a>日志聚合</h2><p>这个可能是比较勉强的用法，只能说可以做，但是不合适。<br>日志系统一般需要如下功能：日志收集、清洗、聚合、存储、展示。而kafka第一件收集就没办法做到。一般来说主机上的log文件存在于一个file中，kafka没法把主机的文件送过来，这个一般由Filebeat\Flume来做，它们就像一个传感器一样，一旦文件由新的内容就会把数据发送出来。<br>日志发送出来之后需要做数据清洗，kafka确实可以帮助我们清洗日志。日志传送过来的之后存在一个topic之后，调用stream来清洗在方法另一个topic，但是这种清洗日志的方式不是很好，每一个日志都要启动一个stream API程序，开启一个java进程来处理，这对于日志数据处理来说代价是有点昂贵。更常规的方案是用logstash来正则匹配。<br>日志聚合就是把不同类型的日志来分流或聚合。<br>现在做日志聚合比较流行的方案是ELK。在每个机器上装个Filebeat agent，由Filebeat来读取数据并发送到Logstash清洗数据，清洗完成之后放到ES存储，由K8S来帮助分析、展示、告警。这个方案有个问题，生产上云主机比较多，产生日志非常多，logstash可能扛不住，它可能出现性能瓶颈。这时候使用kafka部署在filebeat和logstash之间，让logstash慢慢解析，不至于一下子把logstash压垮，kafka类似buffer的作用。</p><h2 id="跟踪网站活动"><a href="#跟踪网站活动" class="headerlink" title="跟踪网站活动"></a>跟踪网站活动</h2><p>kafka最初始作用就是将用户行为跟踪管道重构为一组实时发布-订阅源。把网站活动（浏览网页、搜索或者其他的用户操作）发布到中心topic，每种活动类型对应一个topic。基于这些订阅源，能够实现一系列用例，如实时处理、实时监控、批量地将kafka的数据加载到Hadoop或离线数据仓库系统，进行离线数据处理并生成报告。<br>每个用户浏览网页时产生的活动信息是非常大，kafka很适应这种数据场景。</p><h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><p>使用stream API可以完成。但是使用场景在于数据量下， 并且不想搭建一个完整的流处理平台，需求简单。<br>Kafka社区认为仅仅提供数据生成、消费机制是不够的，他们还需要提供流数据实时处理机制，从0.10.0.0开始，kafka通过提供Streams API来提供轻量，但功能强大的流处理。实际上是Streams API帮助解决流引用中一些棘手的问题，比如：处理无序的数据，代码变化后再次处理数据，进行有状态的流式计算。<br>Streams API的流处理包含多个阶段，从input topics消费数据，做各种处理，将结果写入到目标topic，stream是API基于kafka提供的核心原语构建，它使用kafka consumer、producer来输入、输出，用kafka来做状态存储。<br>流处理框架：flink 、spark streaming、Storm、Samza才是正统的流处理框架，kafka在流处理中更多的是扮演流存储的角色。</p><p>kafka什么时候删除数据？<br>有个配置叫… ，可以配置保留几天的数据。</p><h1 id="Kafka-connect数据传输工具"><a href="#Kafka-connect数据传输工具" class="headerlink" title="Kafka connect数据传输工具"></a>Kafka connect数据传输工具</h1><p>这节讲了大半节zk，然后讲了consumer group。这个数据传输工具没有明讲。</p><h1 id="Kafka-Stream架构"><a href="#Kafka-Stream架构" class="headerlink" title="Kafka Stream架构"></a>Kafka Stream架构</h1><p>传统的MQ在publish消息到MQ后，我们有两种方式sub，一种是拉取（pull）一种是推送（push），不管哪种方式每一个消费端都是消费了MQ中的部分数据。 kafka使用group来完成数据的重复利用，rocketMQ也有同样的group机制。</p><h1 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h1><p>怎么消费效率更高？<br>那就让consumer和partition数量对等，没有什么优化的空间。除了并发度外，还有吞吐的问题，可以调大消费批次，这样拉取的数据更多，那么在消费者性能足够的情况下也可以提高消费效率。</p>]]></content>
    
    
    <categories>
      
      <category>middileware</category>
      
    </categories>
    
    
    <tags>
      
      <tag>middileware</tag>
      
      <tag>mq</tag>
      
      <tag>kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
