

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/q792821266/q792821266.github.io/img/fluid.png">
  <link rel="icon" href="/q792821266/q792821266.github.io/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jerry JIANG">
  <meta name="keywords" content="">
  
    <meta name="description" content="简介RocketMQ是由阿里捐赠给Apache的一款分布式、队列模型的开源消息中间件，经历了淘宝双十一的洗礼。 发展史 2017年孵化了4.0版本 特性 原生的分布式，在设置RocketMQ的时候就是考虑到分布式的场景。消息顺序可以自己制定。RocketMQ有自己的NameServer，自己去实现了集群间信息的同步。以及的消息堆积下性能也很好。类似kafka组的概念，能更好的将消息负载到不同的">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ入门">
<meta property="og:url" content="https://github.com/q792821266/q792821266.github.io/2024/09/08/RocketMQ/index.html">
<meta property="og:site_name" content="Blogs by Jerry">
<meta property="og:description" content="简介RocketMQ是由阿里捐赠给Apache的一款分布式、队列模型的开源消息中间件，经历了淘宝双十一的洗礼。 发展史 2017年孵化了4.0版本 特性 原生的分布式，在设置RocketMQ的时候就是考虑到分布式的场景。消息顺序可以自己制定。RocketMQ有自己的NameServer，自己去实现了集群间信息的同步。以及的消息堆积下性能也很好。类似kafka组的概念，能更好的将消息负载到不同的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/q792821266/q792821266.github.io/indexImg/rocketmq.png">
<meta property="article:published_time" content="2024-09-08T06:42:41.000Z">
<meta property="article:modified_time" content="2024-09-08T08:18:48.533Z">
<meta property="article:author" content="Jerry JIANG">
<meta property="article:tag" content="middileware">
<meta property="article:tag" content="mq">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://github.com/q792821266/q792821266.github.io/indexImg/rocketmq.png">
  
  
  
  <title>RocketMQ入门 - Blogs by Jerry</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/q792821266/q792821266.github.io/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/q792821266/q792821266.github.io/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/q792821266/q792821266.github.io/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"github.com","root":"/q792821266/q792821266.github.io/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"vIZjh6mwkpaLyR4EGVpYtKnD-gzGzoHsz","app_key":"7qo176gafyne1QzTEB2XDr6N","server_url":"https://vizjh6mw.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/q792821266/q792821266.github.io/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/q792821266/q792821266.github.io/js/utils.js" ></script>
  <script  src="/q792821266/q792821266.github.io/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/q792821266/q792821266.github.io/">
      <strong>Jerry&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/q792821266/q792821266.github.io/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/q792821266/q792821266.github.io/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/q792821266/q792821266.github.io/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/q792821266/q792821266.github.io/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/q792821266/q792821266.github.io/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/q792821266/q792821266.github.io/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="RocketMQ入门"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-09-08 14:42" pubdate>
          2024年9月8日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          64 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">RocketMQ入门</h1>
            
            
              <div class="markdown-body">
                
                <meta name="referrer" content="no-referrer"/>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RocketMQ是由阿里捐赠给Apache的一款分布式、队列模型的开源消息中间件，经历了淘宝双十一的洗礼。</p>
<h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647850850657-8219ad44-c38a-4772-a6be-997459f8cc6b.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>2017年孵化了4.0版本</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647850898154-88fa74dd-f26c-409a-a0f1-54ef09efdab7.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>原生的分布式，在设置RocketMQ的时候就是考虑到分布式的场景。消息顺序可以自己制定。RocketMQ有自己的NameServer，自己去实现了集群间信息的同步。以及的消息堆积下性能也很好。类似kafka组的概念，能更好的将消息负载到不同的机器上，均衡压力。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>producer ：消息生产者，负责产生消息，一般由业务系统负责产生消息</li>
<li>consumer ：消息消费者，负责消费消息，一般是后台系统负责异步消息</li>
<li>push consumer ： 封装消息拉取，消费进度和内部</li>
<li>pull consumer ： 主动拉取消息，一旦拉取到消息，应用的消费进程就会进行初始化</li>
<li>Producer Group ：一类Producer的集合名称，这类Producer通常发送一类消息，且发送逻辑一致</li>
<li>Consumer Group：一类Consumer的集合名臣，这些Consumer通常消费一类消息，且消费逻辑一致</li>
<li>Broker：消息中转角色，负责存储消息，转发消息，这里就是RocketMQ Server</li>
<li>Topic：消息的主题，用于定义并在服务端配置，消费者可以按照主题进行订阅，也就是消息分类，通常一个系统一个topic。</li>
<li>Message：在生产者、消费者、服务器之间传递，一个message必须属于一个topic</li>
<li>Namesrv：一个无状态的名称服务，可以集群部署，每一个broker启动的时候都会向名称服务器注册，主要是接收broker的注册，接收客户端的路由请求并返回路由信息</li>
<li>Offset：偏移量，消费者拉取消息时需要知道上一次消费到了什么位置，这一次从哪里开始</li>
<li>Partition：分区，Topic物理上的分组，一个Topic可以分为多个分区，每个分区都是一个有序的队列。分区的每条消息都会分配一个有序的ID，也就是偏移量</li>
<li>Tag：用于对消息进行过滤，可以理解为message的标记，同一个业务不同目的的message可以用相同的topic但是可以用不同的tag来区分。这也是为什么RocketMQ只用一个topic的原因。</li>
<li>key：消费的key字段是为了唯一标识消息，方便查问题，不是说必须设置，但是设置之后会方便开发和运维的定位工作，这个key可以是订单ID等。</li>
</ul>
<p>安装运行，可以参考文档。</p>
<p>运行环境为Centos7，JDK1.8</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912183178-f19648b5-fff9-44ca-b93b-b3bdd573d425.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>下载完成后</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912165861-9a18909f-fc35-4b90-b029-c855a0a629a3.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912202268-f592c4f9-022b-44b2-af90-dbffdc2bc6ac.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>namesev 启动默认会吃掉4G的内存，而broker默认用掉8G，如果测试服务器没有那么高的内存，启动可能报告错误，需要修改配置文件。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912305419-f43f7166-5f5a-43b7-aa23-eef803f8eb7f.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>RocketMQ提供了quickstart，可以快速实现消息的接收与发送。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647912321035-49781e39-1b7b-418a-b1ae-323b1ba47b8c.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<h1 id="架构方案及角色详解"><a href="#架构方案及角色详解" class="headerlink" title="架构方案及角色详解"></a>架构方案及角色详解</h1><h2 id="角色介绍"><a href="#角色介绍" class="headerlink" title="角色介绍"></a>角色介绍</h2><p>RocketMQ由四个角色组成</p>
<ul>
<li>Producer：消费生产者</li>
<li>Consumer：消费者</li>
<li>Broker：MQ服务、负责接收、分发消息</li>
<li>NameServer：负责MQ服务之间的协调</li>
</ul>
<h2 id="架构方案"><a href="#架构方案" class="headerlink" title="架构方案"></a>架构方案</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647913861700-390a09ae-ffa4-4574-9ac2-ad4c91ce4022.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload>	NameServer负责服务发现，每一个MQ服务启动之后会将自己的服务信息组测到NameServer上面，生产者和消费者通过与NameServer建立连接，来知道当前有哪些MQ可以连接。这个过程就是服务发现。</p>
<p>NameServer提供服务注册与发现，还提供路由管理的功能。</p>
<p>当消费者或者生产者选择了一个MQ服务来进行连接，那么连接信息，比如当前生产者连接哪个broker，传输什么消息，处理的是哪个topic，这些都是保存在NameServer。Broker负责的是数据的真实存储和消息的接收与分发。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647914241395-d14bc83a-9b8e-42b3-b9b0-2eebfc43e170.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>继续来详细介绍一下，nameServer 存放mq的服务信息、路由关系、topic、消费者、生产者，而Broker就是实际提供服务的节点。不管是消息发送还是接收，消息都需要有个topic，这个topic数据存放在什么地方，这就涉及到topic的分区。因为是分布式的，所以topic会被分到多个服务器存储。如果是启动了两个broker，这两个broker都是要向nameserver去注册自己的服务信息的。topic就会被分为两个分区去存储，分多少个分区nameserver是会知道的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647930922932-d19dc00b-c09c-4615-862e-fdfbc731d752.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>broker在实际存储的时候，由于topic partition里面还有queue的概念，这个queue个数也是可以配置的（默认4个）。实际上存储到对应的queue里面。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647931052464-17c495ba-2064-464b-8ecf-88262ccf5d19.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>由于里面可能有很多个queue，那么消费者要怎么样才能消费到呢？这是一个消费分发的问题。</p>
<p>consumer负责和其中一台broker建立连接，所以consumer也是要有多个实例的。</p>
<p>考虑启动consumer的情况去消费topic-test，当消费者和namesvr建立连接之后，namesvr会分配一个broker给消费者，broker就会和消费者建立长连接，消费方式只有pull，就算是push模式也是建立在pull上。当第二个消费者再过来连接nameserver的时候，因为nameserver是知道集群中topic，消费者和生产者的关系的，所以nameserver知道partition1是有消费者在消费的，所以会分配partition2给后来的消费者。如果partition中有多个queue，那么消费者会把多个queue都订阅下来消费。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647931450148-5101eb5f-41be-4cae-9674-b68aaa04b6fc.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>上面就是底层实现的一些白话。</p>
<p>消费者与partition尽量保持一样的数量，也可以多部署一些消费者，但是如果数量比queue还多，那么其实消费能力是没有提升的。</p>
<p><strong>一个queue只能有一个消费者去消费，一个消费者可以消费多个queue。</strong>RocketMQ默认一个topic创建4个Queue</p>
<p>通过web管理控制台可以监控查看rocketMQ。</p>
<p>Producer 、 Consumer 、Broker三者的关系是比较简单的。复杂点在于broker除了简单使用外，还有broker的高可用，消息发送到broker，出现异常情况怎么保证消息不丢失。消息数据存储到磁盘，有两种方式，同步或异步。</p>
<ul>
<li>异步：数据会现在内存中存下来，隔一段时间才刷入磁盘，并且不管是否刷入磁盘会立刻返回给客户端。</li>
<li>同步：数据写入磁盘后，才会给客户端响应消息成功送达。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647932318487-494f17a0-3680-4c3e-9218-f8225dc8ad2f.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>响应写入磁盘成功后，如果机器宕机还是会导致数据丢失，于是可以给broker做主从集群。当数据过来写入，到达主服务器写入磁盘之后，主从之间会把消息同步到从服务器。主从同步也是存在同步还是异步的方式，如果是异步，也会出现同步数据丢失的情况。如果设置的是同步的方式，那么消息必须写入从服务器磁盘才会响应客户端，实现高可用。从服务器可以配置多台。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647932564276-37b23494-936b-442b-9777-3043a8f597aa.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<h1 id="搭建与运行RocketMQ"><a href="#搭建与运行RocketMQ" class="headerlink" title="搭建与运行RocketMQ"></a>搭建与运行RocketMQ</h1><p>RocketMQ默认启动就要吃掉8G的内存，我们学习不需要这么高的占用，那就去修改一下配置。</p>
<p>在启动命令里面修改<code>runserver.sh</code>，命名服务器的配置修改</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647914997560-e9ecc17c-9765-4efc-80e2-4e855de07cf8.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>将内存使用大小改为2G，减少资源占用</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647915038376-6d51602b-954f-4e9c-83c3-a60c366a578a.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>同理broker部分也需要修改</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647915098008-3aac0c0b-e1c5-4565-88b8-fd8567f2977c.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>修改完成后进行后台启动<code>nohup sh bin/mqnamesrv &gt; logs/namesrv.log 2&gt;&amp;1 &amp; </code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647920928701-92c1ace1-6199-4f00-932b-941f3df15175.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>接下来要启动broker，broker加载的配置在conf目录下的<code>broker.conf</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921035070-d219f392-f31f-4649-a986-1fbaf7321f21.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>比如设置了双网卡，让外网也能访问到MQ，那么就在这里面指定IP，这样IP会被发布到nameserver注册。这样就可以让外部服务进行使用。这样外部就能通过设置的IP进行访问。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921296201-e475e701-18f5-455a-b8fe-fd569991e30b.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>这个配置文件还可以配置nameserver的目的地。用于告诉broker nameserver的地址，这样才能注册信息上去。但是我们演示的时候用命令行的方式去指定。 <code>nohup sh bin/mqbroker -c conf/broker.conf -n localhost:9876 &gt; logs/broker.log 2&gt;&amp;1 &amp;</code></p>
<p>-c 制定了配置文件，-n 指定了nameserver地址。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921690824-806730bc-6f6e-4f24-ab26-43990fd8c4c2.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>这样就完成了RocketMQ的启动了。</p>
<p>bin目录下有mqadmin，可以查询与控制集群。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647921819236-9a3489ac-19e5-4435-865d-618ea1866745.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>如果没有把nameserver配置为环境变量，那么就需要指定一下nameserver的地址才能调用clusterList</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647924616070-251c977e-fe41-4fed-8722-31bbb23732ac.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>代码示例在rocketMQ-demo。运行代码的过程中可能报告错误</p>
<p>生产者启动后，发送消息时会报以下错：</p>
<p><code>Exception in thread &quot;main&quot; org.apache.rocketmq.client.exception.MQClientException: No route info of this topic, TopicTest</code></p>
<p>原因：</p>
<p>使用RocketMQ进行发消息时，必须要指定topic，对于topic的设置有一个开关autoCreateTopicEnable，一般在开发测试环境中会使用默认设置autoCreateTopicEnable &#x3D; true，但是这样就会导致topic的设置不容易规范管理，没有统一的审核等等，所以在正式环境中会在Broker启动时设置参数autoCreateTopicEnable &#x3D; false。<em>然而，目前的版本中，autoCreateTopicEnable设置为true也不会生效</em></p>
<p>解决方法：</p>
<p>手动通过命令或管理界面创建主题</p>
<p><code>/usr/rocketmq/bin/mqadmin updateTopic -n &#39;192.168.100.242:9876&#39; -c DefaultCluster -t TopicTest</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647943844317-d2f6cdda-bb26-4d95-b165-62690d387d32.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<h1 id="集群配置与搭建"><a href="#集群配置与搭建" class="headerlink" title="集群配置与搭建"></a>集群配置与搭建</h1><p>在rocketMQ里面提供了主从集群的配置。<img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647932830661-534997d8-5247-4d8d-ad94-41c574e1b266.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload><br>2master-2slave-asyns，就是双主双从异步同步。</p>
<p>要注意master之间是不会做数据交互的，数据调度全靠nameServer。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647933025589-39a8423a-9ddc-421f-9c4d-cea6a2f05070.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>文件夹下面是四份配置文件，配置文件的配置项可以去官方看看文档，下图上也有部分配置的简单介绍。</p>
<p>双主双从的话 我们需要六台服务器，nameserver 2台，master 2台，replic 2台。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647933221405-f8704629-ffb4-4ac8-bed5-2c7383d953f3.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>namaserver之间也不存在数据同步，所以有多少个nameserver，broker启动的时候就要在都要注册上去。</p>
<p>对应broker的配置：</p>
<ul>
<li>通过brokerClusterName来标识集群，同名就是同一个集群。</li>
<li>同一个broker主从集群的brokerName是一致的。</li>
<li>通过brokerId 来分辨master与replic ,0代表master 非0代表slave</li>
<li>brokeRole代表主从复制方式，同步或异步</li>
<li>flushDiskType代表内存数据写入磁盘的方式，同步或异步。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938251268-dfbadee4-fbe7-4552-b717-f42026c640da.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>还是要注意一个队列只能有一个消费者去消费，一个消费者可以消费多个队列。只有一个queue搞再多的consumer都没啥用。   </p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938395212-d3d3e3dd-3bee-4e80-9f3f-fe092fce0152.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>数据堆积的大小，清理数据的规则都可以通过配置来完成。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938482384-3aeb2f12-125e-4da0-a02c-c0c834296f1a.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938554390-f7af7e4b-ea5f-4353-8e66-13078fa24ddf.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938565992-8f785fb7-921d-4070-9a06-7fb23b84f1ef.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>看一眼混个眼熟，知道有这么个东西就好。</p>
<h1 id="有序消息"><a href="#有序消息" class="headerlink" title="有序消息"></a>有序消息</h1><h2 id="有序消息的基本概念"><a href="#有序消息的基本概念" class="headerlink" title="有序消息的基本概念"></a>有序消息的基本概念</h2><p>为什么我们需要有序消息。举个例子，我们去银行存钱和取钱，收到用户的请求之后，会发送短信给客户，存钱和取钱的短信通知，可能是同一个sms-topic在物理上分成多个partition。在逻辑上存储在queue，这两个通知会发送到不同的队列中，如果你突然收到一条取钱的短信，估计会被吓一跳。这时候保证消息的顺序是能提高用户的体验的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647938826434-57c1ce8e-6a36-4b00-b762-633592ad8588.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>那么为了保证消息的顺序，就需要把消息发送到同一个queue中，保证只有一个消费者消费，queue本身就是FIFO的保证。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647939164090-b1749752-62b2-4fd7-a747-8ed8ebdfcb13.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647939237781-b417eed3-a5d4-46ab-adb2-b0a30d2e1d65.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<h3 id="全局顺序"><a href="#全局顺序" class="headerlink" title="全局顺序"></a>全局顺序</h3><p>一个Topic内所有消息都发布到同一个queue，按照先进先出的顺序进行发布和消费。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647940074265-54326dd2-e0ac-42c9-8624-cce29e175944.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>适用场景：性能要求不高，所有的消息严格按照FIFO原则进行消息发布和消费的场景。</p>
<p>建议的是一个系统一个topic，所以如果再限制一个queue那效率其实就不高了。</p>
<h3 id="分区顺序"><a href="#分区顺序" class="headerlink" title="分区顺序"></a>分区顺序</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647940631324-70e2684a-5ba0-4549-8796-d9b2a9390276.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>根据消息中的sharding key来进行分区，比如让某种类型统一发送到一个queue中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1647940820102-56e6fd0d-3a14-40da-bad5-d1d75ef11fd3.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>根据sharding key来分配。</p>
<p>适用场景：性能要求高，可根据消息中的sharding key去决定消息发送到哪一个queue。</p>
<p>代码示例OrderedProducer.java</p>
<h3 id="全局消息与分区消息对比"><a href="#全局消息与分区消息对比" class="headerlink" title="全局消息与分区消息对比"></a>全局消息与分区消息对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648000569541-e277b67f-3cc3-4136-a5c8-8393f751d0ad.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>发送方式对比</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648000737617-c24fcec0-f2d4-4f01-aa8e-7bf961144522.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>oneway就是单向发送，比如发送日志消息，不返回任何值，调用者也不关心成功或者失败</p>
<h2 id="如何保证消息顺序"><a href="#如何保证消息顺序" class="headerlink" title="如何保证消息顺序"></a>如何保证消息顺序</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648000909174-9e45d54d-80c3-4f80-995e-edd1072da61c.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648001017624-9b8f7603-8d20-43b6-ae99-36974127475a.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>全局消息只能通过一个消费者来消费，所以性能不高</p>
<p>首先需要顺序的消息必须存储到同一个queue中，这个由producer端实现<code>_&lt;font style=&quot;color:#6c71c4;&quot;&gt;MessageQueueSelector&lt;/font&gt;_</code>  来完成保证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MessageQueueSelector</span> <span class="hljs-variable">messageQueueSelector</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br>    <span class="hljs-comment">// 最后一个参数Object o就是上面讲的sharding key</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; mqs, Message msg, Object o)</span> &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Integer) o;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> id % mqs.size();<br>                <span class="hljs-comment">//分区顺序，同一个模值的消息发送到同一个队列中</span><br>                <span class="hljs-keyword">return</span> mqs.get(index);<br><br>                <span class="hljs-comment">//全局顺序，所有消息发送到一个队列</span><br>                <span class="hljs-comment">//return mqs.get(mqs.size() - 1);</span><br>            &#125;<br>        &#125;;<br><br><span class="hljs-comment">//发送的时候要指定selector 和 sharding key</span><br>SendResult sendResult= producer.send(msg,messageQueueSelector,bizData.get(<span class="hljs-string">&quot;msgType&quot;</span>));<br></code></pre></td></tr></table></figure>

<p>consumer端接收到顺序消费的时候也需要保证消息处理的顺序 ，consumer的关键点在于MessageListenerConcurrently 与  MessageListenerOrderly的注册上。如果是concurrently的话意味并发处理，可能前一条消息没有处理完成，下一条消息就被处理完了，这样是没法保证有序性的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注1：普通消息消费</span><br>        <span class="hljs-comment">/*consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="hljs-comment">            AtomicInteger count = new AtomicInteger(0);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext) &#123;</span><br><span class="hljs-comment">                doBiz(list.get(0));</span><br><span class="hljs-comment">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;);*/</span><br><br>        pushConsumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerOrderly</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> ConsumeOrderlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;<br>                context.setAutoCommit(<span class="hljs-literal">true</span>);<br>                doBiz(msgs.get(<span class="hljs-number">0</span>));<br>                <span class="hljs-keyword">return</span> ConsumeOrderlyStatus.SUCCESS;<br>                        <br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure>



<p>这样才能保证整个消息声明周期的有序。</p>
<h2 id="有序消息的原理"><a href="#有序消息的原理" class="headerlink" title="有序消息的原理"></a>有序消息的原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648004637408-1942b439-6885-43ae-b71e-a5949da41819.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>消息发送的时候，存储在queue可以保证有序性，消费读取消息的时候也能够保证有序。但是有一个点，客户端代码如果没有写好的话是可以造成顺序不一致的。情况不是发生在取数据的过程，而是消费过程处理速率不一致导致的。</p>
<p>RocketMQ消费端有两种类型：MQPullConsumer和MQPushConsumer。本质上底层都是通过pull机制去实现，长轮询（long pull）没有数据会等待而不会断开。pushConsumer是一种API封装。</p>
<h3 id="MQPullConsumer"><a href="#MQPullConsumer" class="headerlink" title="MQPullConsumer"></a>MQPullConsumer</h3><p>MQPullConsumer由用户控制线程，客户端自己通过代码去broker循环拿数据，主动从服务器获取消息，每次获取到的是一个MessageQueue中的消息。PullResult中的<code>List&lt;MessageExt&gt; msgFoundList</code> 自然和存储顺序一致，用户需要在拿到这批消息之后需要自己保证消费的顺序。意味着你可以拿到1 、2、3这样次序的数据，但是先处理2、3，再处理1，处理的逻辑由自己实现。</p>
<h3 id="MQPushConsumer"><a href="#MQPushConsumer" class="headerlink" title="MQPushConsumer"></a>MQPushConsumer</h3><p>MQPushConsumer，通过封装的pull实现。用户通过注册MessageListener来消费消息，在客户端中需要保证调用MessageListener时消息的顺序性。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005304416-cd8343c7-07a9-4b66-bc5a-da5a5321065b.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>在RocketMQ中，实现顺序消息有两个核心类：</p>
<ol>
<li>PullMessageService，目的是去Broker拉取消息，并将消息放在本地的ProcessQueue中</li>
<li>ProcessQueue，我们业务代码处理的数据源头就是这个ProcessQueue</li>
</ol>
<p>不管是pull还是push都是按照上图这种流程。顺序的保证在ProcessQueue中实现。</p>
<p>示例代码中使用到的OrderlyService，核心思路是当多个线程处理同一个processQueue（此时数据其实已经被拉到本地了），会锁住processQueue，不同的queue会有不同线程加锁处理。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005373957-43242cf8-bab2-435f-8cdf-25ad39df25ad.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>结合源码看看：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005721096-51bae813-a0c4-4270-96c1-fd34a1c4c9db.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005734246-492ca577-8849-428d-aa2c-6c8ff569c558.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005747532-210ccf2d-7b05-469b-a828-47d6bc7bc87c.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>在这个start漆面启动了很多的东西，我们关注</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005782651-fa715e5d-da3d-49fa-a811-fc51e913e5d3.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648005820648-eda9eea4-1377-4b59-a301-369d9d600406.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>这就是去broker拉取消息。</p>
<p>将messageListener注册上去之后会进行判断：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648006390048-4d37efc4-3ae4-4e68-8dec-19e0c89dc47a.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>如果是顺序的，那么就可以看到<code>start()</code> 里面存在锁的机制使用。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648006456603-c3974651-7d3d-4cd6-bb25-1cbca64789fe.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<h2 id="有序消息的缺陷"><a href="#有序消息的缺陷" class="headerlink" title="有序消息的缺陷"></a>有序消息的缺陷</h2><p>有序消息使用场景其实并不是很多。有序消息没法利用到集群的故障转移功能，毕竟只有一个queue，没法重试。也可能因为数据热点问题导致一些queue数据量特别大，然后consumer的处理能力却无法提升的尴尬场景。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648006542933-88040553-2549-47d5-a6e9-51c7705b97c4.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<ul>
<li>消费的并行读依赖于queue数量</li>
<li>消费失败时无法跳过（可能可以消费者端自己做处理）</li>
</ul>
<h2 id="有序消息的使用"><a href="#有序消息的使用" class="headerlink" title="有序消息的使用"></a>有序消息的使用</h2><p>参考官网教程： <a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/4.x/producer/03message2/">https://rocketmq.apache.org/docs/4.x/producer/03message2/</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648007130799-b40fa572-7975-4400-a7db-799fe02cad0b.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>是不是有点无语，我当时也是这么无语。当然，学会看官方文档是学习新技术很重要的手段。</p>
<hr>
<h1 id="订阅机制和定时消息"><a href="#订阅机制和定时消息" class="headerlink" title="订阅机制和定时消息"></a>订阅机制和定时消息</h1><h2 id="发布订阅的基本概念"><a href="#发布订阅的基本概念" class="headerlink" title="发布订阅的基本概念"></a>发布订阅的基本概念</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648012647063-479df7f2-a993-4ee2-b722-36e22fa8ceb3.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>发布订阅模式能够实现一个queue被多个消费者消费。在RocketMQ其实没有专门做发布订阅的实现，但是提供了另外的实现。</p>
<p>了解发布订阅前，需要了解一下消息订阅的两种模式：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648012807300-ead98630-602a-4591-8ac3-7003785f3421.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>但是，在RocketMQ中两种方式的具体实现，都是消费端主动从Broker拉取消息。只是说Push模式添加了个监听器，但实际上消息来了还是由消费端pull，是伪push。</p>
<p>代码示例<code>PullConsumer.java</code></p>
<p>pull客户端比较容易出错的地方在于要自己手动控制进度的提交，设置不好，容易出现重复消费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PullConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME_SERVER_ADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建消费者（Pull）对象</span><br>        <span class="hljs-type">DefaultMQPullConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPullConsumer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        consumer.setNamesrvAddr(NAME_SERVER_ADDR);<br>        consumer.start();<br>        <span class="hljs-comment">// 3. 获取到对于topic的queue列表</span><br>        Set&lt;MessageQueue&gt; messageQueues = consumer.fetchSubscribeMessageQueues(<span class="hljs-string">&quot;TopicTest&quot;</span>);<br>        Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 4. 循环遍历</span><br>                <span class="hljs-keyword">for</span> (MessageQueue messageQueue : messageQueues) &#123;<br>                    <span class="hljs-comment">// 5. 获取读取位置</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> consumer.fetchConsumeOffset(messageQueue, <span class="hljs-literal">true</span>);<br>                    <span class="hljs-comment">// 6. 从指定位置取queue中的消息，每次最多10条。  如果没有则阻塞等待</span><br>                    <span class="hljs-type">PullResult</span> <span class="hljs-variable">pullResult</span> <span class="hljs-operator">=</span> consumer.pullBlockIfNotFound(messageQueue, <span class="hljs-literal">null</span>, offset, <span class="hljs-number">10</span>);<br>                    <span class="hljs-comment">// 7. 存储Offset，客户端每隔5s会定时刷新到Broker()</span><br>                    System.out.println(pullResult.getNextBeginOffset());<br>                    consumer.updateConsumeOffset(messageQueue, pullResult.getNextBeginOffset());<br>                    <span class="hljs-comment">// 8. 遍历结果</span><br>                    <span class="hljs-keyword">if</span> (pullResult.getPullStatus() == PullStatus.FOUND) &#123;<br>                        List&lt;MessageExt&gt; messageExtList = pullResult.getMsgFoundList();<br>                        <span class="hljs-keyword">for</span> (MessageExt messageExt : messageExtList) &#123;<br>                            System.out.printf(<span class="hljs-string">&quot;线程：%-25s 接收到新消息 %s --- %s %n&quot;</span>, Thread.currentThread().getName(), messageExt.getTags(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET));<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-number">1000L</span>, <span class="hljs-number">1000L</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以实际使用中pull的方式还是比较少的，常用的方式是用push，push是基于pull上封装的，所以使用起来比较方便，只需要注册一个监听器上去就OK。如果不是有特殊的需要，可以直接用push方法</p>
<h2 id="RocketMQ订阅模式实现原理"><a href="#RocketMQ订阅模式实现原理" class="headerlink" title="RocketMQ订阅模式实现原理"></a>RocketMQ订阅模式实现原理</h2><h3 id="push-推模式"><a href="#push-推模式" class="headerlink" title="push 推模式"></a>push 推模式</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648013250358-8a1c0e21-d2c8-4e1f-ac4c-3b43c5fbe9ae.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>在push模式下，框内的代码已经由RocketMQ帮我们完成了。我们只需要指定订阅主题、 注册监听、以及业务处理代码就OK了</p>
<h3 id="pull-拉模式"><a href="#pull-拉模式" class="headerlink" title="pull 拉模式"></a>pull 拉模式</h3><p>Pull方式里面，取消息的过程就需要自己实现。</p>
<p>基本步骤就是，首先通过消费的topic拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每个MessageQueue批量取消息，一次取完后，记录该队列下一次要取得开始offset，直到取完为止，再换另一个MessageQueue。</p>
<h2 id="订阅模式的使用"><a href="#订阅模式的使用" class="headerlink" title="订阅模式的使用"></a>订阅模式的使用</h2><blockquote>
<p>官方示例：<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/broadcast-example/">https://rocketmq.apache.org/docs/broadcast-example/</a></p>
</blockquote>
<p>BroadcastConsumer 需要最少启动两个才能更好的看到效果</p>
<ul>
<li>MessageModel.BROADCASTING 广播消费模式，所有订阅了同一个主题的消费者都会收到相同的消息</li>
<li>MessageModel.CLUSTERING   集群消费模式，此集群不是指集群环境中的集群，但概念相同，即可实现消息的负载均衡。当有多个消费者订阅了相同的主题时，同一条消息只会有一个消费者消费</li>
</ul>
<p>代码示例：BroadcastConsumer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 3. 设置消息模式，默认是CLUSTERING</span><br><span class="hljs-comment">         * MessageModel.BROADCASTING 广播消费模式</span><br><span class="hljs-comment">         * MessageModel.CLUSTERING   集群消费模式</span><br><span class="hljs-comment">         */</span><br>        consumer.setMessageModel(MessageModel.BROADCASTING);<br></code></pre></td></tr></table></figure>



<p>有一点比较困惑的就是，消费模式是由消费者端设置的。那么如果启动两个消费者，一个设置为广播模式，一个设置为集群消费模式，会出现什么样的效果呢？</p>
<h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>定时消息是指消息发送到Broker后，不能立刻被Consumer消费，要到特定的时间点或者等到特定的事件后才能被消费。</p>
<p>如果要支持任意的时间精度，再Broker层面，必须要做消息排序，如果再涉及持久化，那么消息排序就会不可避免地产生巨大性能开销。</p>
<p>RocketMQ支持定时消息，但是不支持任意时间精度，支持特定的level，例如 定时5s，10s ，1m等。这么做的目的是提高性能。</p>
<h3 id="延迟级别"><a href="#延迟级别" class="headerlink" title="延迟级别"></a>延迟级别</h3><p>在broker端，可以配置延迟级别（level）对应延迟时间的关系，RocketMQ也提供了默认的关系。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648014222577-1531f656-e8a7-434d-aa09-3d4f8dfbd513.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload>Producer会用到这个延迟级别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可以在broker服务器端自行配置messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br>            message.setDelayTimeLevel(<span class="hljs-number">3</span>);<span class="hljs-comment">//这样设置代表着消息发送到broker之后 10s后才能被consumer消费。</span><br></code></pre></td></tr></table></figure>

<p>Consumer端没有需要修改的地方。</p>
<p>这种延迟级别的概念可以说是相当奇怪了，为什么会有这么奇怪的实现呢，与它底层实现有关。</p>
<h3 id="发送逻辑"><a href="#发送逻辑" class="headerlink" title="发送逻辑"></a>发送逻辑</h3><p>首先，对于定时消息的存储，每个等级的消息属于不同的queue，比如等级1的消息会被放到一个queue。这个是有逻辑调整的，与上面的所讲的queue有所不同，存放定时任务的queue和普通消息的queue是分开的。每一个延迟队列都会有topic信息来保持对应关系。</p>
<p>简单来讲，具体实现只是多了一个时间计算的过程。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648014725243-43c74e22-26ef-4c8e-9067-940dc85e8d74.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>源码实现在：ScheduleMessageService.java </p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><blockquote>
<p>官方示例：<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/schedule-example/">https://rocketmq.apache.org/docs/schedule-example/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledMessageProducer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NAME_SERVER_ADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException, RemotingException, MQBrokerException, UnsupportedEncodingException &#123;<br>        <span class="hljs-comment">// 1. 创建生产者对象</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        producer.setNamesrvAddr(NAME_SERVER_ADDR);<br><br>        <span class="hljs-comment">// 3. 启动生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello scheduled message &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss.SS&quot;</span>).format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, content.getBytes(RemotingHelper.DEFAULT_CHARSET));<br><br>            <span class="hljs-comment">// 4. 设置延时等级，此消息将在10秒后传递给消费者</span><br>            <span class="hljs-comment">// 可以在broker服务器端自行配置messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br>            message.setDelayTimeLevel(<span class="hljs-number">3</span>);<br><br>            <span class="hljs-comment">// 5. 发送消息</span><br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> producer.send(message);<br><br>            System.out.printf(<span class="hljs-string">&quot;发送结果：%s%n&quot;</span>, result);<br>            TimeUnit.MILLISECONDS.sleep(RandomUtils.nextInt(<span class="hljs-number">300</span>, <span class="hljs-number">800</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// 6. 停止生产者</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<h1 id="批量消息与事务消息"><a href="#批量消息与事务消息" class="headerlink" title="批量消息与事务消息"></a>批量消息与事务消息</h1><p>这两个特性对于业务需求是很有必要的。</p>
<h2 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h2><p>为什么使用批量消息？</p>
<p>在很多调优的时候，比如数据库批量处理，有些请求进行合并发送等都是类似批量的实现。RocketMQ批量发送也是为了追求性能，将数据堆积到MQ中，特别在消息数量特别大的时候，批量效果就更加明显了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchMessageProducer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException, RemotingException, MQBrokerException, UnsupportedEncodingException &#123;<br>        <span class="hljs-comment">// 1. 创建生产者对象</span><br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 启动生产者</span><br>        producer.start();<br><br>        List&lt;Message&gt; messages = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello batch message &quot;</span> + i;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, content.getBytes(RemotingHelper.DEFAULT_CHARSET));<br><br>            messages.add(message);<br>        &#125;<br>        <span class="hljs-comment">// 5. 发送消息</span><br>        <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> producer.send(messages);<br>        System.out.println(<span class="hljs-string">&quot;消息已发送：&quot;</span> + result);<br><br>        <span class="hljs-comment">// 6. 停止生产者</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>发送的时候不再是一条一条发送，而是发送一个集合。</p>
<p>消费者方面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchMessageConsumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException &#123;<br><br>        <span class="hljs-comment">// 1. 创建消费者（Push）对象</span><br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        consumer.setNamesrvAddr(<span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 订阅对应的主题和Tag</span><br>        consumer.subscribe(<span class="hljs-string">&quot;TopicTest&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br><br>        <span class="hljs-comment">// 4. 设置消息批处理数量，即每次最多获取多少消息，默认是1</span><br>        consumer.setConsumeMessageBatchMaxSize(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-comment">// 5. 注册接收到Broker消息后的处理接口</span><br>        consumer.registerMessageListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>            <span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title function_">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; list, ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 设置消息批处理数量后，list中才会有多条，否则每次只会有一条</span><br>                    <span class="hljs-keyword">for</span> (MessageExt messageExt : list) &#123;<br>                        System.out.printf(<span class="hljs-string">&quot;线程：%-25s 接收到新消息 --- %s %n&quot;</span>, Thread.currentThread().getName(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET));<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 6. 启动消费者(必须在注册完消息监听器后启动，否则会报错)</span><br>        consumer.start();<br><br>        System.out.println(<span class="hljs-string">&quot;已启动消费者&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关键在于使用<code>consumer.setConsumeMessageBatchMaxSize(10);</code> 设置每次获取消息的数量。</p>
<p>RocketMQ默认创建4个Queue，所以消费的时候会创建4个线程来消费。</p>
<p>批量处理数据可以大大提高处理效率，但是也有它的使用限制。</p>
<h3 id="使用批量消息的限制"><a href="#使用批量消息的限制" class="headerlink" title="使用批量消息的限制"></a>使用批量消息的限制</h3><blockquote>
<p>官方示例：<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/batch-example/">https://rocketmq.apache.org/docs/batch-example/</a></p>
</blockquote>
<ul>
<li>同一批次的消息应该具有相同主题（topic），相同的消息配置（tag等）</li>
<li>不支持延迟消息</li>
<li>建议一个批量消息大小最好不要超过1MB。因为使用的是长连接，所以如果传输数据时间过长，会阻塞其他的功能。	1MB是官方建议。</li>
</ul>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>什么是事务消息？</p>
<p>RocketMQ的事务消息，是指Producer端消息发送时间和本地事务事件，同时成功或失败。本地入DB失败，RocketMQ那边也需要回滚 这样的情况。</p>
<h3 id="事务消息设计"><a href="#事务消息设计" class="headerlink" title="事务消息设计"></a>事务消息设计</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1980660/1648021479871-e196a2df-18d1-4fa5-a504-3a6fee3c98da.png" srcset="/q792821266/q792821266.github.io/img/loading.gif" lazyload></p>
<p>当发送消息的时候会</p>
<ol>
<li>先发送Half消息，MQ Server接收到Half消息，存储在MQ中</li>
<li>如果消息发送成功，会返回发送成功的回执给到MQ发送方，表示MQ接收消息成功</li>
<li>MQ发送方就会执行本地事务</li>
<li>本地事务如果成功，就会执行MQ事务的提交，MQ事务是否提交成功也会返回一个回执给到MQ发送方，MQ发送方根据这个回执来决定操作</li>
<li>如果MQserver 没有收到MQ发送方关于本地事务的commite&#x2F;rollback的消息，那么MQ Server会主动的回查数据状态，默认60s，可以配置修改</li>
<li>这个时候MQ发送方应该有操作逻辑去查询本地事务的状态</li>
<li>然后再去通知MQServer提交事务。 MQServer那边如果接收到了commit，才会去投递消息，否则就会删除消息。</li>
</ol>
<p>这个设计注意的点就是第5步，当没有收到commit&#x2F;rollback，MQ会主动会查事务状态。</p>
<p>使用方面：需要实现TransactionListenr中的两个方法，来检查与执行本地事务方法，并且 设置上</p>
<p> <code>producer.setTransactionListener(transactionListenerImpl);</code>然后 <code>producer.setTransactionListener(transactionListenerImpl);</code>发送事务消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionMessageProducer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事务消息监听实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">TransactionListener</span> <span class="hljs-variable">transactionListenerImpl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionListener</span>() &#123;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在发送消息成功时执行本地事务</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> arg producer.sendMessageInTransaction的第二个参数</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 返回事务状态</span><br><span class="hljs-comment">         * LocalTransactionState.COMMIT_MESSAGE：提交事务，提交后broker才允许消费者使用</span><br><span class="hljs-comment">         * LocalTransactionState.RollbackTransaction：回滚事务，回滚后消息将被删除，并且不允许别消费</span><br><span class="hljs-comment">         * LocalTransactionState.Unknown：中间状态，表示MQ需要核对，以确定状态</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>            <span class="hljs-comment">// TODO 开启本地事务（实际就是我们的jdbc操作）</span><br><br>            <span class="hljs-comment">// TODO 执行业务代码（插入订单数据库表）</span><br>            <span class="hljs-comment">// int i = orderDatabaseService.insert(....)</span><br>            <span class="hljs-comment">// TODO 提交或回滚本地事务(如果用spring事务注解，这些都不需要我们手工去操作)</span><br><br>            <span class="hljs-comment">// 模拟一个处理结果</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 模拟返回事务状态</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">switch</span> (index) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    System.out.printf(<span class="hljs-string">&quot;本地事务回滚，回滚消息，id:%s%n&quot;</span>, msg.getKeys());<br>                    <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>                    <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>                <span class="hljs-keyword">default</span>:<br>                    System.out.println(<span class="hljs-string">&quot;事务提交，消息正常处理&quot;</span>);<br>                    <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），</span><br><span class="hljs-comment">         * 由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> 返回事务状态</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(MessageExt msg)</span> &#123;<br>            <span class="hljs-comment">// 根据业务，正确处理： 订单场景，只要数据库有了这条记录，消息应该被commit</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">transactionId</span> <span class="hljs-operator">=</span> msg.getTransactionId();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> msg.getKeys();<br>            System.out.printf(<span class="hljs-string">&quot;回查事务状态 key:%-5s msgId:%-10s transactionId:%-10s %n&quot;</span>, key, msg.getMsgId(), transactionId);<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;id_5&quot;</span>.equals(key)) &#123; <span class="hljs-comment">// 刚刚测试的10条消息， 把id_5这条消息提交，其他的全部回滚。</span><br>                System.out.printf(<span class="hljs-string">&quot;回查到本地事务已提交，提交消息，id:%s%n&quot;</span>, msg.getKeys());<br>                <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;未查到本地事务状态，回滚消息，id:%s%n&quot;</span>, msg.getKeys());<br>                <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, IOException &#123;<br>        <span class="hljs-comment">// 1. 创建事务生产者对象</span><br>        <span class="hljs-comment">// 和普通消息生产者有所区别，这里使用的是TransactionMQProducer</span><br>        <span class="hljs-type">TransactionMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionMQProducer</span>(<span class="hljs-string">&quot;GROUP_TEST&quot;</span>);<br><br>        <span class="hljs-comment">// 2. 设置NameServer的地址，如果设置了环境变量NAMESRV_ADDR，可以省略此步</span><br>        producer.setNamesrvAddr(<span class="hljs-string">&quot;192.168.100.242:9876&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 设置事务监听器</span><br>        producer.setTransactionListener(transactionListenerImpl);<br><br>        <span class="hljs-comment">// 4. 启动生产者</span><br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello transaction message &quot;</span> + i;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span>, <span class="hljs-string">&quot;TagA&quot;</span>, <span class="hljs-string">&quot;id_&quot;</span> + i, content.getBytes(RemotingHelper.DEFAULT_CHARSET));<br><br>            <span class="hljs-comment">// 5. 发送消息(发送一条新订单生成的通知)</span><br>            <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> producer.sendMessageInTransaction(message, i);<br><br>            System.out.printf(<span class="hljs-string">&quot;发送结果：%s%n&quot;</span>, result);<br>        &#125;<br><br>        System.in.read();<br>        <span class="hljs-comment">// 6. 停止生产者</span><br>        producer.shutdown();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="事务消息使用约束"><a href="#事务消息使用约束" class="headerlink" title="事务消息使用约束"></a>事务消息使用约束</h3><ul>
<li>事务不支持定时和批量</li>
<li>为了避免一个消息被多次检查，导致半数队列消息堆积，RokcetMQ限制了单个消息的默认检查次数为15次，通过修改broker配置文件中的transactionCheckMax参数进行调整</li>
<li>特定的时间之后才回查检查事务，通过Broker配置文件参数<code>transactionTimeout</code>或用户配置<code>CHECK_IMMUNITY_TIME_IN_SECONDS</code>调整时间</li>
<li>一个事务消息可能被检查或消费多次</li>
<li>提交过的消息重新放到用户目标topic主题可能会失败</li>
<li>事务消息的生产者ID不能与其他消息类型消息的生产者ID共享，做了事务消息，就不能去做别的了</li>
</ul>
<h3 id="事务消息的状态"><a href="#事务消息的状态" class="headerlink" title="事务消息的状态"></a>事务消息的状态</h3><ul>
<li>TransactionStatus.CommitTransaction：提交事务，允许消费者消费这个事务</li>
<li>TranscationStatus.RollbackTransaction：回滚事务，消息将会被删除或不再允许消费</li>
<li>TransactionStatus.Unknown：中间状态，MQ需要重新检查来确认状态</li>
<li>不返回：也是会回查</li>
</ul>
<h1 id="可视化管理界面"><a href="#可视化管理界面" class="headerlink" title="可视化管理界面"></a>可视化管理界面</h1><p>rocketmq默认不带可视化控制台，需要去单独编译一个工具 <a href="https://github.com/apache/rocketmq-externals">https://github.com/apache/rocketmq-externals</a>  </p>
<ol>
<li><p>git clone源码<code> git clone https://github.com/apache/rocketmq-externals</code></p>
</li>
<li><p>切换版本 <code>git checkout rocketmq-console-1.0.0</code></p>
</li>
<li><p>编译为jar <code>mvn clean package -Dmaven.test.skip=true</code></p>
</li>
<li><p>启动</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">jar包在target目录下面，你可以放在一台服务器上面运行</span><br>java -jar rocketmq-console-ng-1.0.0.jar --server.port=8081--rocketmq.config.namesrvAddr=192.168.100.242:9876<br><span class="hljs-meta prompt_"># </span><span class="language-bash">--server.port springboot内置tomcat的端口号，默认8080；</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--rocketmq.config.namesrvAddr  nameserver的地址</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs">
![](https://cdn.nlark.com/yuque/0/2022/png/1980660/1648030025836-c97b50e6-f8ee-45bf-8e0a-7f8d5cee1ec9.png)、

这样就会启动RocketMQ的控制台。&lt;u&gt;图中参数间没空格，自行改一下&lt;/u&gt;

![](https://cdn.nlark.com/yuque/0/2022/png/1980660/1648030088855-1c746931-8e37-4483-a20b-df5d88a2480d.png)

可以在github 的看到这个控制界面的使用文档。这里就不占用篇幅了。
</code></pre>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/q792821266/q792821266.github.io/categories/middileware/" class="category-chain-item">middileware</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/q792821266/q792821266.github.io/tags/middileware/" class="print-no-link">#middileware</a>
      
        <a href="/q792821266/q792821266.github.io/tags/mq/" class="print-no-link">#mq</a>
      
        <a href="/q792821266/q792821266.github.io/tags/RocketMQ/" class="print-no-link">#RocketMQ</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>RocketMQ入门</div>
      <div>https://github.com/q792821266/q792821266.github.io/2024/09/08/RocketMQ/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jerry JIANG</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年9月8日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/q792821266/q792821266.github.io/2025/04/18/hello-world/" title="Hello World">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/q792821266/q792821266.github.io/2024/07/10/redis/" title="redis简介">
                        <span class="hidden-mobile">redis简介</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"vIZjh6mwkpaLyR4EGVpYtKnD-gzGzoHsz","appKey":"7qo176gafyne1QzTEB2XDr6N","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/q792821266/q792821266.github.io/js/events.js" ></script>
<script  src="/q792821266/q792821266.github.io/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/q792821266/q792821266.github.io/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/q792821266/q792821266.github.io/js/leancloud.js" ></script>

  <script  src="/q792821266/q792821266.github.io/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/q792821266/q792821266.github.io/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
